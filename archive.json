{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-05-25T01:28:05.794642+00:00",
  "repo": "ietf-wg-uuidrev/rfc4122bis",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "Grammar",
      "description": "",
      "color": "c2e0c6"
    },
    {
      "name": "Technical",
      "description": "",
      "color": "FCEDC5"
    },
    {
      "name": "Consensus Requested",
      "description": "",
      "color": "F0E743"
    },
    {
      "name": "Consensus Acheived",
      "description": "",
      "color": "5AFF00"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOH6Ln3M5TLLGk",
      "title": "Errata: Fix uuid_create_md5_from_name() | 1352",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/2",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [1352](https://www.rfc-editor.org/errata/eid1352)\r\n- Status: Verified\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Frank Ellermann\r\n- Date Reported: 2008-03-08\r\n- Verifier Name: Alexey Melnikov\r\n- Date Verified: 2009-12-04\r\n\r\n### Errata\r\nIn Appendix B, it says:\r\n\r\n`uuid_create_md5_from_name(): e902893a-9d22-3c7e-a7b8-d6e313b71d9f`\r\n\r\nIt should say:\r\n\r\n`uuid_create_md5_from_name(): 3d813cbb-47fb-32ba-91df-831e1593ac29`\r\n\r\n### Notes:\r\n\r\nThe given value e902... etc. is based on a calculation swapping the eight octets 0..3, 4..5, 6..7 twice, for the name space UUID, and for the MD5 output, as foreseen for little endian input, but the example values were already big endian. I can reproduce the example and the proposed fix, see <http://omniplex.blogspot.com/2008/03/md5-16-pop3-and-uuid.html>.\r\n\r\nThe blog entry contains links to an identical older error report, and two (different) examples from third parties also agreeing with that theory.",
      "createdAt": "2022-10-03T23:02:24Z",
      "updatedAt": "2023-01-20T15:26:49Z",
      "closedAt": "2023-01-20T15:26:49Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Swapping to `www.example.com` in #6 should render this Errata as fixed.",
          "createdAt": "2022-10-04T22:40:51Z",
          "updatedAt": "2022-10-04T22:40:51Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOH6Ln3M5TLLwz",
      "title": "Errata: Lexicographically Sorting Paragraph Fix | 1428",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/3",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [1428](https://www.rfc-editor.org/errata/eid1428)\r\n- Status: Verified\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Russ Housley\r\n- Date Reported: 2008-05-22\r\n- Verifier Name: Alexey Melnikov\r\n- Date Verified: 2009-12-04\r\n\r\n### Errata\r\nSection 3 says:\r\n\r\n```\r\nUUIDs, as defined in this document, can also be ordered lexicographically.\r\nFor a pair of UUIDs, the first one follows the second if the most significant\r\nfield in which the UUIDs differ is greater for the first UUID.  The second\r\nprecedes the first if the most significant field in which the UUIDs differ\r\nis greater for the second UUID.\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nUUIDs, as defined in this document, can also be ordered lexicographically.\r\nFor a pair of UUIDs, the first one follows the second if the most significant\r\nfield in which the UUIDs differ is greater for the first UUID.  The second\r\nfollows the first if the most significant field in which the UUIDs differ\r\nis greater for the second UUID.\r\n```\r\n\r\n### Notes:\r\n\r\nThe second and third sentences in the paragraph as originally written are\r\ninconsistent. I have proposed one of the possible fixes. There are others\r\nthat will make them consistent.",
      "createdAt": "2022-10-03T23:05:03Z",
      "updatedAt": "2023-01-20T15:26:50Z",
      "closedAt": "2023-01-20T15:26:50Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOH6Ln3M5TLMJN",
      "title": "Errata: Bad Reference to RFC1750 | 3641",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/4",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [3641](https://www.rfc-editor.org/errata/eid3641)\r\n- Status: Verified\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Douglas Ray\r\n- Date Reported: 2013-06-06\r\n- Verifier Name: Barry Leiba\r\n- Date Verified: 2013-06-06\r\n\r\n### Errata\r\nThroughout the document, when it says:\r\n\r\n```\r\nAdvice on generating cryptographic-quality random numbers can be\r\n   found in RFC1750 [5].\r\n```\r\nIt should say:\r\n\r\n```\r\nAdvice on generating cryptographic-quality random numbers can be\r\n   found in RFC4086 [5].\r\n```\r\n\r\n### Notes:\r\n\r\n(Above sample is from section 4.5).\r\nReferences to RFC 1750 should currently refer to RFC 4086.\r\n(Likewise in Appendix A.)\r\nThe note [5] actually references RFC4086, but this is the only\r\npoint that is updated, ie, the document is inconsistent in its references.\r\nThe references in Appendix A are not cross-referenced to note [5].\r\n\r\n### Verifier notes\r\nThis is correct: reference [5] was updated to point to 4086, but the text in the\r\ndocument body was not changed accordingly.",
      "createdAt": "2022-10-03T23:06:39Z",
      "updatedAt": "2023-01-20T15:26:50Z",
      "closedAt": "2023-01-20T15:26:50Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOH6Ln3M5TLMlZ",
      "title": "Errata: Incorrect Parenthesis usage Section 4.3 | 184",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/5",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [184](https://www.rfc-editor.org/errata/eid184)\r\n- Status: Verified\r\n- Type: Editorial\r\n- Publication Format(s) : TEXT\r\n- Reported By: Tim Wilson-Brown\r\n- Date Reported: 2006-05-03\r\n- Verifier Name: Alexey Melnikov\r\n- Date Verified: 2009-12-04\r\n\r\n### Errata\r\nSection 4.3 says:\r\n\r\n```\r\nThe UUIDs generated from the same name in two different namespaces\r\n       should be different with (very high probability).\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nThe UUIDs generated from the same name in two different namespaces\r\n       should be different (with very high probability).\r\n```\r\n\r\n### Notes:\r\n\r\nThe brackets should be set similarly to the other points.",
      "createdAt": "2022-10-03T23:08:49Z",
      "updatedAt": "2023-01-20T15:26:51Z",
      "closedAt": "2023-01-20T15:26:51Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOH6Ln3M5TLM4S",
      "title": "Errata: Change MD5 website to example.com | 3476",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/6",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [3476](https://www.rfc-editor.org/errata/eid3476)\r\n- Status: Verified\r\n- Type: Editorial\r\n- Publication Format(s) : TEXT\r\n- Reported By: Simon Kissane\r\n- Date Reported: 2013-02-02\r\n- Verifier Name: Barry Leiba\r\n- Date Verified: 2013-02-03\r\n\r\n### Errata\r\nSection Appendix A,B says:\r\n\r\n```\r\nIn Appendix A, the line:\r\n    uuid_create_md5_from_name(&u, NameSpace_DNS, \"www.widgets.com\", 15);\r\nIn Appendix B, the line:\r\n     uuid_create_md5_from_name(): e902893a-9d22-3c7e-a7b8-d6e313b71d9f\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nIn Appendix A, the line:\r\n    uuid_create_md5_from_name(&u, NameSpace_DNS, \"www.example.com\", 15);\r\nIn Appendix B, the line:\r\n     uuid_create_md5_from_name(): 5df41881-3aed-3515-88a7-2f4a814cf09e\r\n```\r\n\r\n### Notes:\r\n\r\nPer RFC2606 section 5, it is best practice for standards and other documentation (including RFCs) to use the reserved example domains (e.g. example.com) rather than domains which could be in actual use. Indeed, the domain in question (www.widgets.com) is in actual use at the time of writing. So this proposed change uses \"www.example.com\" instead, and changes the example output accordingly. (Note that original output was wrong for the original input, as already noted in verified errata 1352.)",
      "createdAt": "2022-10-03T23:10:18Z",
      "updatedAt": "2023-01-20T15:26:51Z",
      "closedAt": "2023-01-20T15:26:51Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOH6Ln3M5TLNJG",
      "title": "Errata: Fix reference to variant in octet 8 | 4975",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/7",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Technical"
      ],
      "body": "### Errata ID: [4975](https://www.rfc-editor.org/errata/eid4975)\r\n- Status: Reported\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Joseph Boon\r\n- Date Reported: 2017-03-22\r\n\r\n### Errata\r\nSection 4.1 says:\r\n\r\n```\r\nThe UUID format is 16 octets; some bits of the eight octet variant \r\nfield specified below determine finer structure.\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nThe UUID format is 16 octets; some bits of the variant \r\nfield specified below determine finer structure.\r\n```\r\n\r\n### Notes:\r\n\r\nThe original wording implies the variant field is 8 octets long. It is between 1 and 3 bits long. An alternative correction would be:\r\n\r\n\"The UUID format is 16 octets; some bits of the variant\r\nfield in octet 8 specified below determine finer structure.\"",
      "createdAt": "2022-10-03T23:11:39Z",
      "updatedAt": "2023-01-20T15:27:15Z",
      "closedAt": "2023-01-20T15:27:15Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOH6Ln3M5TLNnj",
      "title": "Errata: Further clarify 3rd/last bit of Variant for spec | 5560",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/8",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Technical"
      ],
      "body": "### Errata ID: [5560](https://www.rfc-editor.org/errata/eid5560)\r\n- Status: Reported\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: GLOBAL UUID DATABASE\r\n- Date Reported: 2018-11-25\r\n\r\n\r\n### Errata\r\nSection 4.1.1 says:\r\n\r\n\r\n```\r\n   The following table lists the contents of the variant field, where\r\n   the letter \"x\" indicates a \"don't-care\" value.\r\n\r\n   Msb0  Msb1  Msb2  Description\r\n    0     x     x    Reserved, NCS backward compatibility.\r\n    1     0     x    The variant specified in this document.\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\n   The following table lists the contents of the variant field, where\r\n   the letter \"x\" indicates a \"don't-care\" value.\r\n\r\n   Msb0  Msb1  Msb2  Description\r\n\r\n    0     x     x    Reserved, NCS backward compatibility.\r\n\r\n    1     0     0    The variant specified in this document.\r\n```\r\n\r\n### Notes:\r\n\r\nIf Msb2 is a \u00ab don't-care \u00bb value, this means it's not wrong to set the bit to 0 or 1.\r\nIn the case of UUIDv3 and UUIDv5, this does not specify if the bit from the hash output should be left untouched or not.\r\nIt's not stated that it's illegal to reset it to 0 when setting Msb0 and Msb1 altogether (as libuuid does), since it's a \u00ab don't-care \u00bb value.\r\nBut letting it untouched whenever it's set to 1 by the hash output (as the Python stdlib does) causes two UUIDv{3,5} to be different for the same input namespaces and data. (Example: NS=Nil UUID, data = 0x44 (\u00abD\u00bb).\r\n\r\nThe RFC should enforce the value of the bit to 0 or 1, or clarify if it should be left untouched depending on the context-dependent data (Clock ID {1,2}, hash output {3,5}, random input {4}). (Which would mean it's then just a libuuid bug to forcibly set Msb2 to 0 when it should be untouched.)\r\n\r\nSee also : https://uuid.pirate-server.com/blog/brother-uuids-or-why-uuids-are-not-unique.html",
      "createdAt": "2022-10-03T23:14:26Z",
      "updatedAt": "2023-01-20T15:27:16Z",
      "closedAt": "2023-01-20T15:27:15Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOH6Ln3M5TLN1B",
      "title": "Errata: Fix BAD OID acronym | 6225",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/9",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [6225](https://www.rfc-editor.org/errata/eid6225)\r\n- Status: Reported\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Daniel Marschall\r\n- Date Reported: 2020-07-07\r\n\r\n### Errata\r\nSection 4.3 says:\r\n\r\n```\r\nISO Object IDs (OIDs)\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nObject Identifiers (OIDs)\r\n```\r\n\r\n### Notes:\r\n\r\nAn Object Identifier (OID) is an identification mechanism jointly developed by ITU-T and ISO/IEC.\r\n\r\nIt makes no sense saying that it is an \"ISO OID\". Actually, it can be very confusing, because people could think that \"ISO OID\" means an OID which is a descendant of { iso(1) }, which would exclude OIDs descending from { itu-t(0) } and { joint-iso-itu-t(2) }.\r\n\r\nAlso in Appendix C, \"Name string is an ISO OID\" should be changed to \"Name string is an OID\".\r\n\r\nMaybe it would also be good to mention how the OID should be formatted. I guess the intention of the author is the normal dot-notation \"2.999\" which is passed as ASCII text to the name-based UUID generation function.",
      "createdAt": "2022-10-03T23:15:35Z",
      "updatedAt": "2023-01-20T15:26:52Z",
      "closedAt": "2023-01-20T15:26:52Z",
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOH6Ln3M5TLOQT",
      "title": "Errata: Fix clock_seq_hi_and_reserved most-significant bit verbiage | 4976",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/10",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Technical"
      ],
      "body": "### Errata ID: [4976](https://www.rfc-editor.org/errata/eid4976)\r\n- Status: Reported\r\n- Type: Editorial\r\n- Publication Format(s) : TEXT\r\n- Reported By: Joseph Boon\r\n- Date Reported: 2017-03-22\r\n\r\n\r\n### Errata\r\nThroughout the document, when it says:\r\n\r\n```\r\nSet the two most significant bits (bits 6 and 7) of the\r\nclock_seq_hi_and_reserved to zero and one, respectively.\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nSet the two most significant bits (bits 7 and 6) of the\r\nclock_seq_hi_and_reserved to one and zero, respectively.\r\n```\r\n\r\n### Notes:\r\n\r\nThe original wording appears in sections 4.2.2, 4.3, and 4.4. It can lead to confusion about which bit is most significant (6 or 7), and does not align neatly with the table of Variants in section 4.1.1 (which shows 1 followed by 0 for msb0 and msb1). The revised wording specifies the bits in msb order, which helps the reader more clearly correlate the bit values with section 4.1.1. It is noted that the revised wording would not match other parts of the document which give the lsb number first (e.g. \"bits 32 through 47\"), but this case is different because it is specifying fixed values for two bits, and the sentence starts with \"Set the two most significant bits\".",
      "createdAt": "2022-10-03T23:18:03Z",
      "updatedAt": "2023-01-20T15:27:16Z",
      "closedAt": "2023-01-20T15:27:16Z",
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDOH6Ln3M5TLOfd",
      "title": "Errata: Typo in code comment | 6665",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/11",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [6665](https://www.rfc-editor.org/errata/eid6665)\r\n- Status: Reported\r\n- Type: Editorial\r\n- Publication Format(s) : TEXT\r\n- Reported By: Andrzej Koszela\r\n- Date Reported: 2021-08-25\r\n\r\n### Errata\r\nSection Appendix A says:\r\n\r\n```\r\nstatic unsigned16 true_random(void);\r\n\r\n/* uuid_create -- generator a UUID */\r\nint uuid_create(uuid_t *uuid)\r\n{\r\n     uuid_time_t timestamp, last_time;\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nstatic unsigned16 true_random(void);\r\n\r\n/* uuid_create -- generate a UUID */\r\nint uuid_create(uuid_t *uuid)\r\n{\r\n     uuid_time_t timestamp, last_time;\r\n```\r\n\r\n### Notes:\r\n\r\nThe comment above the declaration of uuid_create() uses \"generate a UUID\", so the comment above the definition is likely intended to be identical.",
      "createdAt": "2022-10-03T23:19:30Z",
      "updatedAt": "2023-01-20T15:26:52Z",
      "closedAt": "2023-01-20T15:26:52Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOH6Ln3M5TLOwe",
      "title": "Errata: Better Clarify network byte order when referencing most significant bits | 3546",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/12",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Technical"
      ],
      "body": "### Errata ID: [3546](https://www.rfc-editor.org/errata/eid3546)\r\n- Status: Held for Document Update\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Askar Safin\r\n- Date Reported: 2013-03-14\r\n- Held for Document Update by: Barry Leiba\r\n- Date Held: 2013-03-20\r\n\r\n### Errata\r\nSection 4.1.3 says:\r\n\r\n```\r\nThe version number is in the most significant 4 bits of the time\r\nstamp (bits 4 through 7 of the time_hi_and_version field).\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nThe version number is in the most significant 4 bits of the time\r\nstamp (bits 0 through 3 of the time_hi_and_version field).\r\n```\r\n\r\n### Notes:\r\n\r\nWe use network order (as far as I know, we use network order in this RFC both for bits and bytes). So, the most significant bits comes first and they are located in first bytes. So, 0 through 3.\r\n\r\n### VERIFIER NOTES\r\nThis erratum is correct as far as it goes, but, given other text in the RFC, so is erratum 1957. There is a pervasive problem in this RFC with inconsistent and unclear usage of bit numbering, which switches between several conventions. The diagram in Section 4.1.2 uses left-to-right bit numbering (the most significant bit is numbered 0), but much of the text (such as in Section 4.2.2) uses right-to-left bit numbering (the least significant bit is numbered 0). Most of the text uses big-ending byte order (network byte order), but some seems to assume little-ending, probably mistakes that come from the authors' familiarity with that convention.\r\n\r\nWith respect to the text in question, the first sentence of Section 4.1.3, we have the following situation:\r\n\r\n- The original text is correct if we assume right-to-left bit numbering and little-endian byte order.\r\n\r\n- Erratum 1957 is correct if we assume right-to-left bit numbering and big-endian byte order. This change also makes the first sentence of Section 4.1.3 consistent with the sixth bullet in Section 4.2.2.\r\n\r\n- Erratum 3546 is correct if we assume left-to-right bit numbering and big-endian byte order.\r\n\r\nIn the end, the real point is that this document needs a revision that carefully and thoroughly fixes every instance of byte numbering (or removes the byte numbering and refers only to \"most significant\" and \"least significant\"). Such a revision should also double-check the sample code in Appendix A to be sure it works in both big-ending and little-endian machines.\r\n\r\nHappily, it's not likely that misunderstandings here will cause actual interoperability problems: this isn't a situation where things need to be disassembled and reassembled. The algorithm merely turns a UUID into a URN, and the URN is thereafter a \"black box\", an unchanged identifier. The only issue would be whether different interpretations of the document would turn two different UUIDs into the same URN, and, given the number of bits involved, the likelihood of collisions in practice is small.",
      "createdAt": "2022-10-03T23:21:07Z",
      "updatedAt": "2023-01-25T20:12:11Z",
      "closedAt": "2023-01-25T20:12:11Z",
      "comments": [
        {
          "author": "safinaskar",
          "authorAssociation": "NONE",
          "body": "I'm author of errata [3546](https://www.rfc-editor.org/errata/eid3546). Just now I carefully have read relevant fragment of https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-00.txt , i. e. this paragraph:\r\n\r\n> The version number is in the most significant 4 bits of octet 6.\r\n   More specifically bits 48 through 51.  The remaining 4 bits of Octet\r\n   6 are dynamic.\r\n\r\nSo, I'm sure this errata (regarding this paragraph) is fixed. Thanks a lot.\r\n\r\nAlso, it seems bits and bytes numbers are zero-based. I don't see mentions of this starting from begin of this document through this paragraph",
          "createdAt": "2022-11-23T12:36:07Z",
          "updatedAt": "2022-11-23T12:36:07Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> So, I'm sure this errata (regarding this paragraph) is fixed. Thanks a lot.\r\n\r\nThanks for the confirmation @safinaskar \r\n\r\n> Also, it seems bits and bytes numbers are zero-based. I don't see mentions of this starting from begin of this document through this paragraph\r\n\r\nI have this paragraph in Section 5 (being moved to section 4). I believe when moved to the correct spot this should address your concern.\r\n\r\n```\r\nWhile discussing UUID field layouts, bit definitions start at 0 and end at 127 while octets definitions start at 0 and end at 15.\r\n```\r\nEdit, https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-01.html#name-uuid-format\r\n",
          "createdAt": "2023-01-20T15:30:17Z",
          "updatedAt": "2023-01-23T23:18:56Z"
        },
        {
          "author": "safinaskar",
          "authorAssociation": "NONE",
          "body": "> I believe when moved to the correct spot this should address your concern.\r\n\r\nYes, I see",
          "createdAt": "2023-01-24T14:56:56Z",
          "updatedAt": "2023-01-24T14:56:56Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOH6Ln3M5TLPBt",
      "title": "Errata: Fix 4.1.3 reference to the correct bits | 1957",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/13",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Technical"
      ],
      "body": "### Errata ID: [1957](https://www.rfc-editor.org/errata/eid1957)\r\n- Status: Held for Document Update\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Sergey Shandar\r\n- Date Reported: 2009-12-03\r\n- Held for Document Update by: Barry Leiba\r\n- Date Held: 2013-03-20\r\n\r\n### Errata\r\nSection 4.1.3 says:\r\n\r\n```\r\nThe version number is in the most significant 4 bits of the time\r\nstamp (bits 4 through 7 of the time_hi_and_version field).\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nThe version number is in the most significant 4 bits of the time\r\nstamp (bits 12 through 15 of the time_hi_and_version field).\r\n```\r\n\r\n### Notes:\r\n\r\ntime_hi_and_version is defined as 16 bit field.\r\n\r\n### VERIFIER NOTES\r\nThis change does make the text in Section 4.1.3 consistent with the sixth\r\nbullet in Section 4.2.2. But the issue goes well beyond that: there is a real\r\nproblem with the bit numbering throughout the RFC. Please see erratum\r\n3546 for more details.",
      "createdAt": "2022-10-03T23:22:42Z",
      "updatedAt": "2023-01-20T15:27:16Z",
      "closedAt": "2023-01-20T15:27:16Z",
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOH6Ln3M5UioIX",
      "title": "Draft 02: Describe Nil/Max UUID in variant table",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/16",
      "state": "CLOSED",
      "author": "ben221199",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "At the moment, the Nil-UUID is part of variant 0 and by that definition reserved. Variant 0 uses `AF_UNSPEC` in that case.\r\n\r\nHowever, the range of the Omni-UUID isn't reserved yet. This issue suggests to reserve a variant of the Omni-UUID. I would suggest to only reserve the `0xFF` variant. Why? I will explain.\r\n\r\nIn the early days of UUID, there was no such thing as variants. There was only \"family\". This family field consisted of only one single byte, so it ranged from 0 to 255. In modern days, this is the same byte as where the variant byte is in. With this information, the new variant table will be this:\r\n| Msb0 | Msb1 | Msb2 | As Byte | Values | Description |\r\n| - | - | - | - | - | - |\r\n| 0 | * | * | `0b0*******` | From 0 to 127 | Reserved, NCS backward compatibility. |\r\n| 1 | 0 | * | `0b10******` | From 128 to 191 | The variant specified in this document. |\r\n| 1 | 1 | 0 | `0b110*****` | From 192 to 223 | Reserved, Microsoft Corporation backward compatibility |\r\n| 1 | 1 | 1 | `0b111*****`<br>---<br>`0b11111111` | From 224 to 254<br>---<br>Only 255 | Reserved for future definition.<br>---<br>Omni-UUID variant |\r\n\r\nHandling the variant/family like this, it has at least 2 advantages:\r\n - It reserves a variant for the Omni-UUID, so that there will be no conflicts when a new variant will be specificed.\r\n - You clearly see that there are 31 variant slots open for definition (32 including Omni-UUID variant).\r\n\r\nThis doesn't mean that Variant 255 always should have all bits set to 1. It only reserves the range the Omni-UUID is in. I also think it is important to add this variant in this specification, because this specification defines the Omni-UUID itself.",
      "createdAt": "2022-10-21T13:41:59Z",
      "updatedAt": "2023-02-16T22:14:22Z",
      "closedAt": "2023-02-16T22:14:22Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems logical enough to me. I will slate it for IETF 115 discussion in addition to cross posting to the mailing group.",
          "createdAt": "2022-10-21T20:05:59Z",
          "updatedAt": "2022-10-21T20:05:59Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "Makes sense. I agree some clarification is necessary because Table 1 looks to conflict with Max UUID, but by the way, do we need to limit the variant field to one byte rather than the remaining 64 bits? Even after our great-great-grandchildren consume `0b1111_1110`, they can still define `0b1111_1111_0`. The variant field is variable-length by its nature, so perhaps it is more helpful to describe the `10` technique explicitly. I haven't come up with a good idea to do this, but how about something like this?\r\n\r\n| Msb0 | Msb1 | Msb2 | Msb3 | Description                                            |\r\n| ---- | ---- | ---- | ---- | ------------------------------------------------------ |\r\n| 0    | x    | x    | x    | Reserved, NCS backward compatibility.                  |\r\n| 1    | 0    | x    | x    | The variant specified in this document.                |\r\n| 1    | 1    | 0    | x    | Reserved, Microsoft Corporation backward compatibility |\r\n| 1    | 1    | 1    | 0    | Reserved for a future variant.                        |\r\n| 1    | 1    | 1    | 1    | Reserved for future variants and Max UUID.           |\r\n\r\nOr this?\r\n\r\n| Msb0 | Msb1 | Msb2 | Description                                            |\r\n| ---- | ---- | ---- | ------------------------------------------------------ |\r\n| 0    | x    | x    | Reserved, NCS backward compatibility.                  |\r\n| 1    | 0    | x    | The variant specified in this document.                |\r\n| 1    | 1    | 0    | Reserved, Microsoft Corporation backward compatibility |\r\n| 1    | 1    | 1    | Reserved for future variants and Max UUID.           |\r\n",
          "createdAt": "2022-11-02T12:41:29Z",
          "updatedAt": "2022-11-02T12:51:01Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "We could also say \"Reserved for the next future variant.\" for `0b1110`.",
          "createdAt": "2022-11-02T12:58:19Z",
          "updatedAt": "2022-11-02T12:58:19Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "> The variant field is variable-length by its nature, so perhaps it is more helpful to describe the 10 technique explicitly.\r\n\r\nThis is not fully correct. Forget about how the table is in RFC 4122. In the good old Apollo Computer days, there was a `family` field that was exactly 8 bits. Because only 13 families where used back then, the makers of RFC 4122 decided when starting with a 0-bit, it was variant 0 and defined families, and when starting with a 1-bit, it was another variant.\r\n\r\nMaking the variant field variable length, doesn't make any sense. It was defined on the same location as the family field on purpose. I would almost rather say: the variant field IS the family field.\r\n\r\n---\r\n\r\nWhat I think should be done? Well, I would recommend to redefine all variants to their 8-bit format, where `x` is a \"don't care\", so variant `0` becomes `0xxxxxxx`, variant `10` becomes `10xxxxxx` and variant `110` becomes `110xxxxx`. Why is this useful? Because you can assign ranges to it (see column 'Values' in my table). Instead of checking seperate bits, you just read the `family` byte, check the ranges, and you know the variant. Using 8-bit notation is also easier to understand and better to use in some IANA registry.\r\n\r\n---\r\n\r\n> do we need to limit the variant field to one byte rather than the remaining 64 bits?\r\n\r\nLook at what happened to `10xxxxxx`. This variant supports multiple versions. If you are afraid of running out of variants in the future, just reserve one variant now using the 8-bit notation and write an RFC that defines how your subversioning works, just like variant 1 in RFC 4122. Problem solved.\r\n",
          "createdAt": "2022-11-02T15:31:10Z",
          "updatedAt": "2022-11-02T15:31:10Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "So this...\r\n\r\nMsb0 | Msb1 | Msb2 | Description\r\n-- | -- | -- | --\r\n0 | x | x | Reserved, NCS backward compatibility.\r\n1 | 0 | x | The variant specified in this document.\r\n1 | 1 | 0 | Reserved, Microsoft Corporation backward compatibility\r\n1 | 1 | 1 | Reserved for future variants and Max UUID.\r\n\r\n...should become this...\r\n\r\nMsb0 | Msb1 | Msb2 | Msb3 | Msb4 | Msb5 | Msb6 | Msb7 | Description | Range\r\n-- | -- | -- | -- | -- | -- | -- | -- | -- | --\r\n0 | x | x | x | x | x | x | x | Reserved, NCS backward compatibility. | From 0 to 127 \r\n1 | 0 | x | x | x | x | x | x | The variant specified in this document. | From 128 to 191\r\n1 | 1 | 0 | x | x | x | x | x | Reserved, Microsoft Corporation backward compatibility | From 192 to 223\r\n1 | 1 | 1 | x | x | x | x | x | This was `Reserved for future definition.` in RFC 4122. Now we can reserve variant 224 to 254 for new formats and reserve 255 for Omni-UUID. This gives us space for 31 new variants. If you are afraid of running out of these variants soon, define one now and write an RFC about it, just like how variant 128-191 works with `versions`. | From 224 to 255\r\n\r\n...in my opinion.",
          "createdAt": "2022-11-02T15:40:36Z",
          "updatedAt": "2022-11-02T15:40:36Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "We can just forget about the family field because, as long as Msb0 is set to 1, no ID will collide with `0b0` variant values. Technically, the `0b1` authors could have done whatever they liked using the remaining 63 bits, but they generously gave up Msb1 so the future authors could use `0b11`. We should pay it forward; those who claim `0b111` should stick to `0b1110` and reserve `0b1111` for future authors. Similarly, `0b1111` should reserve `0b1111_1`, `0b1111_1` should reserve `0b1111_11`, `0b1111_11` should reserve `0b1111_111`, and so on. Accordingly, the table should look like this in full:\r\n\r\n| Msb0 | Msb1 | Msb2 | Msb3 | Msb4 | Msb5 | Msb6 | ... | Msb63 | Msb64 | Description                                            |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | --- | ----- | ----- | ------------------------------------------------------ |\r\n| 0    | x    | x    | x    | x    | x    | x    | ... | x     | x     | Reserved, NCS backward compatibility.                  |\r\n| 1    | 0    | x    | x    | x    | x    | x    | ... | x     | x     | The variant specified in this document.                |\r\n| 1    | 1    | 0    | x    | x    | x    | x    | ... | x     | x     | Reserved, Microsoft Corporation backward compatibility |\r\n| 1    | 1    | 1    | 0    | x    | x    | x    | ... | x     | x     | Reserved for the 1st future variant.                   |\r\n| 1    | 1    | 1    | 1    | 0    | x    | x    | ... | x     | x     | Reserved for the 2nd future variant.                   |\r\n| 1    | 1    | 1    | 1    | 1    | 0    | x    | ... | x     | x     | Reserved for the 3rd future variant.                   |\r\n| 1    | 1    | 1    | 1    | 1    | 1    | 0    | ... | x     | x     | Reserved for the 4th future variant.                   |\r\n| ...  | ...  | ...  | ...  | ...  | ...  | ...  | ... | ...   | ...   | ...                                                    |\r\n| 1    | 1    | 1    | 1    | 1    | 1    | 1    | ... | 1     | 0     | Reserved for the last future variant.                  |\r\n| 1    | 1    | 1    | 1    | 1    | 1    | 1    | ... | 1     | 1     | Reserved for Max UUID.                                 |\r\n",
          "createdAt": "2022-11-02T17:40:41Z",
          "updatedAt": "2022-11-02T17:40:41Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": " I don't think this is useful. First, we don't need 18446744073709551616 variants, or in this case 64 variants (what actually isn't very different from 32, so I don't see a reason for having 64), I think we could better use this amount of possibilities for identifying objects, not variants. Second, maybe someone don't want have subversioning on the bytes directly after the `family` field, maybe he wants is at the beginning of the UUID or somewhere else.",
          "createdAt": "2022-11-02T18:58:27Z",
          "updatedAt": "2022-11-02T18:58:27Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "Perhaps, at this stage, we don't need to say in the RFC what the `0b111` taker should do. So, just keeping Table 1 as is or the following should be enough:\r\n\r\n| Msb0 | Msb1 | Msb2 | Description                                            |\r\n| ---- | ---- | ---- | ------------------------------------------------------ |\r\n| 0    | x    | x    | Reserved, NCS backward compatibility.                  |\r\n| 1    | 0    | x    | The variant specified in this document.                |\r\n| 1    | 1    | 0    | Reserved, Microsoft Corporation backward compatibility |\r\n| 1    | 1    | 1    | Reserved for future variants and Max UUID.             |\r\n\r\nIt doesn't really make sense to reserve one byte and order the next variant author to use `0b1110_0000`. It wastes precious five bits for forward compatibility, which is too costly in my opinion. A new variant will be rarely necessary; the `0b10` variant is sufficient unless there is a serious need to remove the `ver` field, so we don't need to declare a large `var` space right now. Let's just leave it to the `0b111` takers like: https://github.com/uuid6/uuid6-ietf-draft/issues/26\r\n",
          "createdAt": "2022-11-02T22:47:56Z",
          "updatedAt": "2022-11-02T22:47:56Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I think your last row in the table is a very bad thing to do. Also, you contradict yourself by saying that my way is too costly, but we also don't need many variants. Note that version can only hold 16 values, where half of it is already taken. Also, https://github.com/uuid6/uuid6-ietf-draft/issues/26 is out of scope.",
          "createdAt": "2022-11-03T20:15:40Z",
          "updatedAt": "2022-11-03T20:15:40Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "> I think your last row in the table is a very bad thing to do.\r\n\r\nCan you please elaborate on this point?\r\n\r\n> Also, you contradict yourself by saying that my way is too costly, but we also don't need many variants.\r\n\r\nNot contradictory. Because we don't need many variants, reserving one byte for `var` is too costly.\r\n\r\n> Note that version can only hold 16 values, where half of it is already taken. Also, https://github.com/uuid6/uuid6-ietf-draft/issues/26 is out of scope.\r\n\r\nI'm afraid you are confusing versions and variants. Versions are specific to the `0b10` variant and have nothing to do with the future variants. If the future `0b111` authors believe they need sub-variants, they will allocate another version bits somewhere in the 128-bit space. If not, the version field will simply go away and the four bits will be utilized differently. We should let them decide, as we can't foresee the future.\r\n\r\nOn the other hand, if the future authors are considerate enough of the future of UUID spec, they will likely take the `0b1110` variant so the next future authors can take `0b1111`, just as https://github.com/uuid6/uuid6-ietf-draft/issues/26 tried to. E variant is out of scope, but the discussion clearly demonstrates how the `var` field can be utilized in the future. Similarly, `0b1111` takers are likely to reserve `0b1111_1`, `0b1111_1` takers to reserve `0b1111_11`, and so on. In this way, the `var` field can be variable-length, which might grows over many decades. I don't mean we should reserve 64 variants right now.\r\n\r\nI now think it's a good idea to add one paragraph below Table 1 stating the above intention to guide future authors like:\r\n\r\n> Future RFC authors who consume the reserved \"111\" variant are encouraged to (or, simply, SHOULD) define the \"1110\" variant and reserve the \"1111\" variant so that the next future authors can extend the UUID specification using the \"1111\" variant as well as the new variant does not conflict with the Max UUID.\r\n\r\nWe can only encourage (but not enforce) this rule because, as long as `var` starts with `0b111`, the future authors can do whatever they want without conflicting with the old standards. We cannot enforce the \"one byte `var`\" rule either for the same reason.\r\n",
          "createdAt": "2022-11-04T00:23:17Z",
          "updatedAt": "2022-11-04T00:23:17Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Repeating my comment from The January IETF interim meeting:\r\nAre we over engineering a solution? \r\n\r\nThis reads like we just want to clarify within the table that Nil/Max (omni) are present in the variant ranges.\r\n\r\nCould we not update the table to say:\r\n`Reserved, NCS backward compatibility and includes Nil UUID <insert section reference>`\r\n`Reserved for future definition and includes Max UUID <insert section reference>`",
          "createdAt": "2023-01-20T15:33:19Z",
          "updatedAt": "2023-01-20T15:33:48Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Seems to me a reasonable solution for now. It reserves the range where Omni-UUID is in for later definition, but also already tells to take into account having a variant for it in the future.\r\n\r\nOne addition: It seems the RFC at the moment will only documentate variant 1 (and its subversions). Maybe it is also good to documentate variant 0 (and its subfamilies). Because variant 0 family 0 is `af_unspec`, it is compatible with old specifications to documentate variant 0 and also include Nil-UUID:\r\n![image](https://user-images.githubusercontent.com/12856904/213872412-1e3732f8-fe84-4f6b-82aa-63fc56adb639.png)\r\n```\r\n *\r\n * Internal structure of variant #0 UUIDs\r\n *\r\n * The first 6 octets are the number of 4 usec units of time that have\r\n * passed since 1/1/80 0000 GMT.  The next 2 octets are reserved for\r\n * future use.  The next octet is an address family.  The next 7 octets\r\n * are a host ID in the form allowed by the specified address family.\r\n *\r\n * Note that while the family field (octet 8) was originally conceived\r\n * of as being able to hold values in the range [0..255], only [0..13]\r\n * were ever used.  Thus, the 2 MSB of this field are always 0 and are\r\n * used to distinguish old and current UUID forms.\r\n *\r\n * +--------------------------------------------------------------+\r\n * |                    high 32 bits of time                      |  0-3  .time_high\r\n * +-------------------------------+-------------------------------\r\n * |     low 16 bits of time       |  4-5               .time_low\r\n * +-------+-----------------------+\r\n * |         reserved              |  6-7               .reserved\r\n * +---------------+---------------+\r\n * |    family     |   8                                .family\r\n * +---------------+----------...-----+\r\n * |            node ID               |  9-16           .node\r\n * +--------------------------...-----+\r\n *\r\n */\r\n```\r\nSource: https://opensource.apple.com/source/CF/CF-299.35/Base.subproj/uuid.c.auto.html\r\n\r\nSo, for Nil-UUID:\r\n - All `time` bits are zero\r\n - All `reserved` bits are zero by definition\r\n - All `family` bits are zero. The first bit tells us it is variant 0; in combination with the other 7 bits, we also know the family: `AF_UNSPEC`. Because the family is `UNSPEC`, we don't have to follow any family format rules.\r\n - All `node ID` bits are zero.\r\n\r\nThen, we can change the description text for variant zero to:\r\n`Apollo NCS format [Section x.x], including Nil-UUID [Section y.y].`",
          "createdAt": "2023-01-21T15:01:09Z",
          "updatedAt": "2023-01-21T15:01:09Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@ben221199, maybe I can sneak Variant 0 and its sub-families into an appendix or I could link that source exactly as a reference.\r\nI would hate to add technical information we are not fully in control of. Basically treat it like UUIDv2m \"out of our control go to this doc to read about it.\" and insert the source.",
          "createdAt": "2023-01-23T21:12:35Z",
          "updatedAt": "2023-01-23T21:12:35Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I think an appendix would be okay for now. In that case, at least the variant is included in the RFC, so no linking to sources that can disappear in the future, but not part of the main specification. I'm cool with that.",
          "createdAt": "2023-01-24T20:56:05Z",
          "updatedAt": "2023-01-24T20:56:05Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOH6Ln3M5UzWdv",
      "title": "Typo in UUIDv7 test vector?",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/17",
      "state": "CLOSED",
      "author": "oittaa",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis#appendix-C.6\r\n\r\nThere might be a typo in final UUIDv7 test vector.\r\n\r\n```\r\n   -------------------------------\r\n   field      bits    value\r\n   -------------------------------\r\n   unix_ts_ms   48    0x17F22E279B0\r\n   ver           4    0x7\r\n   rand_a       12    0xCC3\r\n   var           2    b10\r\n   rand_b       62    b01, 0x8C4DC0C0C07398F\r\n   -------------------------------\r\n   total       128\r\n   -------------------------------\r\n   final: 017F22E2-79B0-7CC3-98C4-DC0C0C07398F\r\n```\r\n\r\nI think it actually yields 017F22E2-79B0-7CC3-***8***8C4-DC0C0C07398F.\r\n\r\nHere's how I generated it simply from Python command line.\r\n\r\n```python\r\nhex(0x8C4DC0C0C07398F | 2 << 62 | 0xCC3 << 62 + 2 | 0x7 << 62 + 2 + 12 | 0x17F22E279B0 << 62 + 2 + 12 + 4)\r\n'0x17f22e279b07cc388c4dc0c0c07398f'\r\n```\r\n\r\nFor example the version 6 works as expected and matches the result `1EC9414C-232A-6B00-B3C8-9E6BDECED846`.\r\n\r\n```\r\n   -----------------------------------------------\r\n   field                 bits    value\r\n   -----------------------------------------------\r\n   time_high              32     0x1EC9414C\r\n   time_mid               16     0x232A\r\n   time_low_and_version   16     0x6B00\r\n   clk_seq_hi_res          8     0xB3\r\n   clock_seq_low           8     0xC8\r\n   node                   48     0x9E6BDECED846\r\n   -----------------------------------------------\r\n   total                 128\r\n   -----------------------------------------------\r\n   final_hex: 1EC9414C-232A-6B00-B3C8-9E6BDECED846\r\n```\r\n\r\n```python\r\nhex(0x9E6BDECED846 | 0xC8 << 48 | 0xB3 << 48 + 8 | 0x6B00 << 48 + 8 + 8 | 0x232A << 48 + 8 + 8 + 16 | 0x1EC9414C << 48 + 8 + 8 + 16 + 16)\r\n'0x1ec9414c232a6b00b3c89e6bdeced846'\r\n```",
      "createdAt": "2022-10-25T16:24:30Z",
      "updatedAt": "2022-10-25T16:42:47Z",
      "closedAt": "2022-10-25T16:42:46Z",
      "comments": [
        {
          "author": "oittaa",
          "authorAssociation": "NONE",
          "body": "Oh sorry, I didn't notice `b01` part for some reason. The following works as expected.\r\n\r\n```python\r\n>>> hex(0x8C4DC0C0C07398F | 1 << 60 | 2 << 62 | 0xCC3 << 62 + 2 | 0x7 << 62 + 2 + 12 | 0x17F22E279B0 << 62 + 2 + 12 + 4)\r\n'0x17f22e279b07cc398c4dc0c0c07398f'\r\n```",
          "createdAt": "2022-10-25T16:42:46Z",
          "updatedAt": "2022-10-25T16:42:46Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOH6Ln3M5VbdTY",
      "title": "Draft 01: Mixed Case Spelling error",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/18",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "\"mixe case\" in text spelled wrong.",
      "createdAt": "2022-11-02T14:37:28Z",
      "updatedAt": "2023-01-20T17:12:30Z",
      "closedAt": "2023-01-20T17:12:30Z",
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDOH6Ln3M5VbeF1",
      "title": "Draft 01: Add \"UUIDs that Do Not Identify the Host as well\" reference to security considerations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/19",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "> MAC addresses pose inherent security risks and SHOULD not be used within a UUID. Instead CSPRNG data SHOULD be selected from a source with sufficient entropy to ensure guaranteed uniqueness among UUID generation. See Section 6.8 for more information.\r\n\r\nAdd reference to 6.9.  UUIDs that Do Not Identify the Host as well",
      "createdAt": "2022-11-02T14:38:53Z",
      "updatedAt": "2023-01-20T17:12:31Z",
      "closedAt": "2023-01-20T17:12:31Z",
      "comments": []
    },
    {
      "number": 20,
      "id": "I_kwDOH6Ln3M5VbefG",
      "title": "Draft 01: Out of Place Distributed node text",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/20",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "> Distributed applications generating UUIDs at a variety of hosts must be willing to rely on the random number source at all hosts. If this is not feasible, the namespace variant should be used.\r\n\r\nCopied from RFC4122, needs moved to distributed node section vs Security considerations for better readability.",
      "createdAt": "2022-11-02T14:39:37Z",
      "updatedAt": "2023-01-20T17:12:31Z",
      "closedAt": "2023-01-20T17:12:31Z",
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOH6Ln3M5VlZ3O",
      "title": "Draft 01: v6 clock_seq and node usage ambiguity",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/21",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Section 5.6 says \"the 48 bit node SHOULD be set to a pseudo-random value\". Which does it mean:\r\n\r\n1. the node SHOULD be reset to a pseudo-random number every time a new UUIDv6 is generated; or,\r\n2. the node SHOULD be initialized at a pseudo-random number only once at the system boot?\r\n\r\nThe old RFC 4122 doesn't seem clear enough, or it is rather so permissive as to accept many kinds of spatially unique identifiers. It's okay for v1 to be ambiguous; we must anyway keep it as ambiguous as it has been. Since v6 should be compatible with v1, everything should also be permitted under v6, but questions arise on which method v6 should recommend as default. We don't need to be ambiguous here.\r\n\r\nIf the first option is the way to go, the following text in Section 5.6:\r\n\r\n> The clock sequence bits remain unchanged from their usage and position in Section 5.1.\r\n>\r\n> The 48 bit node SHOULD be set to a pseudo-random value however implementations MAY choose to retain the old MAC address behavior from Section 5.1 and Section 6.9. For more information on MAC address usage within UUIDs see the Section 9\r\n\r\ncan be reworded in a much simpler way as:\r\n\r\n> The clock sequence and node bits SHOULD be reset to a pseudo-random value for each new UUIDv6 generated; however, implementations MAY choose to retain the UUIDv1 behavior from Section 5.1.\r\n\r\nbecause the clock sequence bits are reset to a random number when the node ID changes. Refreshing `node` to a random number every time is equivalent to resetting both `clock_seq` and `node` to random numbers every time. This point seems clear from Section 4.2.1 and Appendix A of the old RFC 4122.\r\n\r\nIf the latter option is recommended, the RFC should state that explicitly.",
      "createdAt": "2022-11-04T10:36:29Z",
      "updatedAt": "2023-01-19T19:23:48Z",
      "closedAt": "2023-01-19T19:23:48Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Good points and brings up a discussion we had on the interim meeting and during IETF 115 today on the topic of \"when to initialize random\" your two numbered bullets describe the two scenarios and I need to add some security considerations around usage of number 1 which can potentially exhaust random entropy sources. \r\n\r\nI'll slate this for Draft 01 and see what verbiage I can come up with for the mailing list to sign off on. ",
          "createdAt": "2022-11-08T18:30:53Z",
          "updatedAt": "2022-11-08T18:30:53Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOH6Ln3M5V31m4",
      "title": "Draft 01: Figure 2 and 3 Fix Title",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/22",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "`Figure 2: Example Hex UUID` -> `Figure 3: Example Binary UUID`\r\n`Figure 3: Example Hex UUID` -> `Figure 3: Example Integer UUID`\r\n\r\n",
      "createdAt": "2022-11-08T18:27:23Z",
      "updatedAt": "2023-01-20T17:12:32Z",
      "closedAt": "2023-01-20T17:12:32Z",
      "comments": []
    },
    {
      "number": 23,
      "id": "I_kwDOH6Ln3M5V34Xx",
      "title": "Draft 01: Move Namespace Registration Template to IANA Considerations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/23",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "As per IETF 115 discussion, moving this from appendix to IANA considerations + update to latest and greatest format as per RFC8141",
      "createdAt": "2022-11-08T18:36:46Z",
      "updatedAt": "2023-01-20T18:03:26Z",
      "closedAt": "2023-01-20T18:03:26Z",
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOH6Ln3M5V35Uv",
      "title": "Draft 01: Verify ABNF formatting against RFC5234",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/24",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Specifically should these be `4hexOctet` or `4*hexOctet` as per https://www.rfc-editor.org/rfc/rfc5234#section-3.6",
      "createdAt": "2022-11-08T18:40:09Z",
      "updatedAt": "2023-01-20T17:12:32Z",
      "closedAt": "2023-01-20T17:12:32Z",
      "comments": []
    },
    {
      "number": 25,
      "id": "I_kwDOH6Ln3M5V35gy",
      "title": "Draft 01: Bump ABNF reference to RFC 5234",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/25",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "https://www.rfc-editor.org/rfc/rfc5234",
      "createdAt": "2022-11-08T18:40:45Z",
      "updatedAt": "2023-01-20T17:12:33Z",
      "closedAt": "2023-01-20T17:12:33Z",
      "comments": []
    },
    {
      "number": 26,
      "id": "I_kwDOH6Ln3M5V35sh",
      "title": "Draft 02: More Security Considerations Randomness",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/26",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "As per Brendan Moran, notes on this will be delivered on the emailer to add to security considerations.",
      "createdAt": "2022-11-08T18:41:21Z",
      "updatedAt": "2023-02-16T22:14:22Z",
      "closedAt": "2023-02-16T22:14:22Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Possibly add reference that points too:\r\nhttps://github.com/peteroupc/peteroupc.github.io/blob/master/random.md",
          "createdAt": "2023-01-10T17:35:40Z",
          "updatedAt": "2023-01-10T17:35:40Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "Perhaps you could use this sentence structure:\r\n\r\n_Implementations MUST ${verb_phrase} unless explicitly stated otherwise._\r\n\r\nWe see this structure in some specifications like this paragraph in [RFC-4648](https://www.rfc-editor.org/rfc/rfc4648):\r\n\r\n>   Implementations MUST reject the encoded data if it contains\r\n>   characters outside the base alphabet when interpreting base-encoded\r\n>   data, unless the specification referring to this document explicitly\r\n>   states otherwise.\r\n\r\nIn this case, a possible instance of this structure is:\r\n\r\n_Implementations MUST use a cryptographically-secure PRNG unless the documentation explicitly states otherwise._\r\n\r\nIn other words, if the implementer uses a Xorshift generator, they MUST make that clear in the documentation.\r\n\r\nDoes that make sense to you?\r\n",
          "createdAt": "2023-02-05T07:38:07Z",
          "updatedAt": "2023-02-05T07:47:35Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@fabiolimace the problem with using a MUST is there is no alternative and by adding \"unless the documentation explicitly states otherwise\" it sort of goes against the defined MUST. \r\n\r\nSHOULD verbiage allows an alternative assuming you know the risks and have a good reason for doing so. e.g some old machine/library that can only do PRNG and not CSPRNG.\r\n\r\nI also don't see any reference to RFC 4648 in our doc? What made you look at that spec?",
          "createdAt": "2023-02-06T15:23:54Z",
          "updatedAt": "2023-02-06T15:24:29Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "I understand. The SHOULD modal allows for an alternative approach.\r\n\r\n<s>I think it would be nice if the user of the code could know when the implementation isn't using a PRNG as recommended by the spec, especially when the code is closed and it's not possible to verify this.</s> **EDIT**: sorry no one would do it.\r\n\r\nBy the way, I was reading this RFC-4648 and I randomly remembered this issue. Let's forget it. :)",
          "createdAt": "2023-02-08T01:47:00Z",
          "updatedAt": "2023-02-08T01:57:36Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOH6Ln3M5V36Fy",
      "title": "Draft 01: Modify v8 SHOULD NOT to MUST NOT",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/27",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "`UUIDv8's uniqueness will be implementation-specific and SHOULD NOT be assumed`\r\n\r\nTO\r\n\r\n`UUIDv8's uniqueness will be implementation-specific and MUST NOT be assumed`\r\n\r\nfrom Murray K. IETF 115",
      "createdAt": "2022-11-08T18:42:41Z",
      "updatedAt": "2023-01-20T17:12:33Z",
      "closedAt": "2023-01-20T17:12:33Z",
      "comments": []
    },
    {
      "number": 28,
      "id": "I_kwDOH6Ln3M5V36p4",
      "title": "Draft 01: Review and possibly add OID items from X.667 ",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/28",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specifically OID in integer format and hex-and-dash format. \r\nLikely section: UUID Format",
      "createdAt": "2022-11-08T18:44:35Z",
      "updatedAt": "2022-12-08T21:20:10Z",
      "closedAt": "2022-12-08T21:20:10Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDOH6Ln3M5V37px",
      "title": "Draft 01: Remove \"time-based\" constraint from version 8 UUID",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/29",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Source https://github.com/uuid6/uuid6-ietf-draft/issues/124",
      "createdAt": "2022-11-08T18:48:02Z",
      "updatedAt": "2023-01-20T17:12:34Z",
      "closedAt": "2023-01-20T17:12:34Z",
      "comments": []
    },
    {
      "number": 30,
      "id": "I_kwDOH6Ln3M5V37vf",
      "title": "Draft 01: Further clarify v7 field description #125",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/30",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Source: https://github.com/uuid6/uuid6-ietf-draft/issues/125",
      "createdAt": "2022-11-08T18:48:21Z",
      "updatedAt": "2023-01-20T17:12:34Z",
      "closedAt": "2023-01-20T17:12:34Z",
      "comments": []
    },
    {
      "number": 31,
      "id": "I_kwDOH6Ln3M5V3-KU",
      "title": "Draft 02: SHOULD vs MUST BCP 14 review everywhere",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/31",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per IETF 115, Murray K.(?):\r\nLikely slated for Draft 02 but need to have somebody, non author/editor, review every SHOULD and answer if a defined alternative exists within the text and ultimately if that SHOULD:\r\n- Stays as is since there are clearly defined edge cases\r\n- Increases to a MUST since there is no reason not too / no alternative\r\n- Decreases further to a MAY ",
      "createdAt": "2022-11-08T18:56:38Z",
      "updatedAt": "2023-04-06T16:01:18Z",
      "closedAt": "2023-04-06T16:01:18Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Jim:\r\n> Section 5.7:  \"SHOULD utilize UUID version 7\": explain why, and under \r\n> what circumstances versions 1 and 6 are acceptable.",
          "createdAt": "2023-01-20T16:40:50Z",
          "updatedAt": "2023-01-20T16:40:50Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOH6Ln3M5YxaRm",
      "title": "Typo:  Section 4.2, Version Field, \"UUID from in this\"",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/33",
      "state": "CLOSED",
      "author": "broofa",
      "authorAssociation": "NONE",
      "assignees": [
        "kyzer-davis"
      ],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "\"The Gregorian time-based UUID ~~from~~ in this document\"",
      "createdAt": "2022-12-11T03:19:37Z",
      "updatedAt": "2023-01-20T17:12:49Z",
      "closedAt": "2023-01-20T17:12:49Z",
      "comments": []
    },
    {
      "number": 38,
      "id": "I_kwDOH6Ln3M5cYEMI",
      "title": "RFC 5234",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/38",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`The formal definition of the UUID string representation is provided by the following ABNF [[RFC4234](https://ietf-wg-uuidrev.github.io/rfc4122bis/draft-00/draft-ietf-uuidrev-rfc4122bis.html#RFC4234)]:`\r\n\r\nEtc. are wrong.\r\n",
      "createdAt": "2023-01-19T19:25:20Z",
      "updatedAt": "2023-01-20T16:38:10Z",
      "closedAt": "2023-01-20T16:38:09Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "(idnits is a useful tool that quickly finds things like this.\r\nAvailable via <https://author-tools.ietf.org>.)",
          "createdAt": "2023-01-19T19:41:53Z",
          "updatedAt": "2023-01-19T19:41:53Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, covered under #25 for Draft 01",
          "createdAt": "2023-01-20T16:38:09Z",
          "updatedAt": "2023-01-20T16:38:09Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOH6Ln3M5cYFQq",
      "title": "Create better ABNF to represent Hex Digit",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/39",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Please use a more common form of identifying hexdigit in the IETF.\r\n\r\nCertainly\r\n\r\n```\r\nhexDigit =\r\n      \"0\" / \"1\" / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\" / \"9\" /\r\n      \"a\" / \"b\" / \"c\" / \"d\" / \"e\" / \"f\" /\r\n      \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\r\n[\u00b6](https://ietf-wg-uuidrev.github.io/rfc4122bis/draft-00/draft-ietf-uuidrev-rfc4122bis.html#appendix-A-2.8.5)\r\n``` \r\n\r\nis suboptimal as both \"a\" and \"A\" identify a case-insensitive letter A.\r\n\r\nE.g.:\r\n``` \r\n   hexDigit = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\r\n``` \r\n\r\nOr use the % form:\r\n\r\n``` \r\n   DIGIT           = %x30-39\r\n   hexDigit      = DIGIT / %x61-66 / %x41-47\r\n```\r\n\r\n",
      "createdAt": "2023-01-19T19:28:27Z",
      "updatedAt": "2023-01-23T22:55:18Z",
      "closedAt": "2023-01-23T22:55:18Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo, this looks to do the trick and condense it down nicely.\r\nIt looks like `%x41-47` should be `%x41-46` since it includes the uppercase G.\r\n\r\nNote, the `CRLF` below is just so `anbfgen` will output each on a new line else it outputs in a big jumbled mess. I will remove it. \r\n\r\nI am open to either however RFC5234 specifies HEXDIGIT and DIGIT in core rules so I say we use that over my second example.\r\nSource: https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\r\n\r\n### Test 1\r\n```\r\nkydavis@ubuntu-22:~/abnfgen/abnfgen-0.20$ cat abnf-new.txt\r\n   UUID     = 4hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              6hexOctet CRLF\r\n   hexOctet = HEXDIG HEXDIG\r\n   DIGIT    = %x30-39\r\n   HEXDIG   = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\r\n\r\nkydavis@ubuntu-22:~/abnfgen/abnfgen-0.20$ ./abnfgen abnf-new.txt -n 10\r\nABEfdbaF-ffAb-Aedb-CEe3-C0bDBE4Bdeed\r\n2DafADBE-a8DA-CCE6-bBFA-dBAdcaeDFDFa\r\nADEEdCAd-dAEE-DdeD-EbAD-cf68FeAAFeCc\r\n5fa7dEea-d4DF-3Ceb-FDAb-FEbFcCE6dbED\r\nefEEadeA-ACfE-fdCD-EBCF-b1ccF6dDc6F7\r\nBFFeDEcc-FDdd-1Fdf-FBf7-AfaCcdfcBEFB\r\nfC7ADE0A-ccdF-b9aC-FCaB-D31cDFAAbCee\r\n6dAAdb2F-dEDB-aFAB-Fad3-adDfceAEcCbD\r\ndFAFCBfc-EbBb-fdC2-Bb3F-CB5BAfCdBaAD\r\nFD2bb3eE-dba5-fEeA-eCDB-bb5ddeAFcaBF\r\n```\r\n\r\n### Test 2\r\n```\r\nkydavis@ubuntu-22:~/abnfgen/abnfgen-0.20$ cat abnf-new-2.txt\r\n   UUID     = 4hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              6hexOctet CRLF\r\n   hexOctet = hexDigit hexDigit\r\n   hexDigit = %x30-39 / %x61-66 / %x41-46\r\n              ; 0-9, a-f, A-F\r\n\r\nkydavis@ubuntu-22:~/abnfgen/abnfgen-0.20$ ./abnfgen abnf-new-2.txt -n 10\r\nAfEA4BFc-0BcB-DB63-9d3E-DF32bbb8BF1B\r\nc17aae0d-7c8f-11db-CF1E-EDA6eC8eF7e7\r\n3B7edB6C-5eac-A2d2-e6AD-c31416c1b74F\r\n29CD0f1C-F80F-ca4a-a7DB-ffAeffaEC84c\r\n0Ef606D4-4B30-C16c-Fdd3-Fbe3Ced1Ea2A\r\n6baAAfBc-FDbC-e1a7-ca81-2e55bfbcbCbb\r\n6F0F7ac7-bDbB-FCDD-1cEf-1F851cD95cff\r\n0AAaAeda-90aa-FE2D-3AEB-Bf75cfB3abDc\r\nFCe208c7-FAFc-B0aB-5DDB-cB9a08406EB3\r\nBCfeCaC8-f80c-D57f-91f5-6DbaBD46D1AC\r\n```",
          "createdAt": "2023-01-20T15:24:06Z",
          "updatedAt": "2023-01-20T15:24:06Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "I agree.\r\nYou probably should add a comment that ABNF strings are case-insensitive -- people are not used to that any more in 2023.\r\n",
          "createdAt": "2023-01-20T16:43:17Z",
          "updatedAt": "2023-01-20T16:43:17Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "I_kwDOH6Ln3M5ccWN3",
      "title": "Draft 01: Break Binary form of UUID into two lines.",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/40",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "From Jim\r\n> Section 4, figure 2: The binary UUID has been truncated because the \r\n> line is too long. Figure out how to split into two lines.\r\n\r\nFrom Kyzer\r\n> I wondered about that; it worked fine for HTML rendering but TXT it isn't good.\r\n> I can open an issue to use one of the methods in RFC8792 e.g `backslash` or `double backslash` techniques.",
      "createdAt": "2023-01-20T14:23:43Z",
      "updatedAt": "2023-01-20T17:12:50Z",
      "closedAt": "2023-01-20T17:12:50Z",
      "comments": []
    },
    {
      "number": 41,
      "id": "I_kwDOH6Ln3M5cdKtU",
      "title": "Move octet text from section 4 to section 5",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/41",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 4.1: \"octet 8\" is the first mention of an octet number. Should\r\nsomething be said about octet numbering first? For example, most significant octet first, starting with 0\r\n\r\nKyzer:\r\n> Yes, I noticed this myself, I have text in Section 5.0 start that defines the start of octet descriptors. I will open an issue to move this to section 4.0. ",
      "createdAt": "2023-01-20T16:39:35Z",
      "updatedAt": "2023-01-23T22:55:04Z",
      "closedAt": "2023-01-23T22:55:04Z",
      "comments": []
    },
    {
      "number": 42,
      "id": "I_kwDOH6Ln3M5cdK4L",
      "title": "Add forward reference to UUIDv1 and UUIDv4 in Section 2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/42",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n\r\n> Section 2: UUIDv4 (item 1) and UUIDv1 (item 2) references: Should \r\n> these be forward references to later sections of the document?\r\n\r\nKyzer:\r\n> Yes, that is likely a good thing to do. I used v1 and v4 for those Section 2 examples since they are \"very well known\" so I opted to use them to hammer home the finer UUID structure details. I will open an issue to track this.",
      "createdAt": "2023-01-20T16:40:16Z",
      "updatedAt": "2023-01-23T22:55:04Z",
      "closedAt": "2023-01-23T22:55:04Z",
      "comments": []
    },
    {
      "number": 43,
      "id": "I_kwDOH6Ln3M5cdL3X",
      "title": "Draft 02: Expand multiplexed fields within v1 and v6 bit definitions",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/43",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 5.1: Figure 6 (and also Figure 10) contain the \r\n> `time_hi_and_version` field. Why not make the version field separate, as it is for example in Figure 7? Make the \"var\" field separate as well.\r\n\r\nKyzer:\r\n> In UUIDv1 this is from the old document and kept for historical reasons (many libraries use this descriptor in the code or documentation) For UUIDv6 we kept it to better show the relationship between the two layouts. \r\n\r\nJan 22' Interim Meeting:\r\n> Consensus from the group was to modify these since they cause confusion. Same for `clk_seq_hi_res `\r\n\r\nKyzer:\r\n> This will cause lots of rippling changes to v1/v6 sections along with appendix examples for both. Need to be meticulous that this expansion is handled properly. Better for next draft to focus on just that change.",
      "createdAt": "2023-01-20T16:43:36Z",
      "updatedAt": "2023-02-16T22:14:23Z",
      "closedAt": "2023-02-16T22:14:23Z",
      "comments": []
    },
    {
      "number": 44,
      "id": "I_kwDOH6Ln3M5cdMNu",
      "title": "Draft 02: Expand upon why unix epoch rollover is not a problem",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/44",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 6.1: Length: Perhaps directly address why the Unix epoch \r\n> rollover is not a concern here.",
      "createdAt": "2023-01-20T16:44:29Z",
      "updatedAt": "2023-02-16T22:14:23Z",
      "closedAt": "2023-02-16T22:14:23Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Had to dig deep but I knew we discussed this. \r\nhttps://github.com/uuid6/uuid6-ietf-draft/issues/23#issuecomment-898939437\r\n\r\n10889 AD for v7 at 48 bits and MS resolution\r\n5623 AD for v1/v6 at 60 bits and 100-NS resolution",
          "createdAt": "2023-02-09T21:51:22Z",
          "updatedAt": "2023-02-09T21:51:22Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOH6Ln3M5cdMgA",
      "title": "Erronous reference to v1 in monotonicity",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/45",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 6.2: In paragraph 3, it refers to monotonicity of UUID version 1.\r\n> But version 1 is not monotonic at a high level because the byte order is wrong, so it will not be seen by applications not explicitly looking at the version field as monotonic. It might be good to point that out, especially since this is one of the motivations for the new UUID versions.\r\n\r\nKyzer:\r\n> Yes, I will open a tracker item to remove version 1 from that sentence.",
      "createdAt": "2023-01-20T16:45:20Z",
      "updatedAt": "2023-01-23T22:55:05Z",
      "closedAt": "2023-01-23T22:55:05Z",
      "comments": []
    },
    {
      "number": 46,
      "id": "I_kwDOH6Ln3M5cdMpZ",
      "title": "Add Label for \"Monotonic Error Checking\" paragraph to frame the topic",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/46",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim\r\n> Section 6.2, last sentence: I don't understand this.\r\n\r\nKyzer:\r\n> General guidance on error checking e.g. \"is our current UUID larger than the previous\". If it makes more sense, I can open an issue to give it a label of \"Monotonic Error Checking\" like we have with the rest of the items in that section.",
      "createdAt": "2023-01-20T16:45:50Z",
      "updatedAt": "2023-01-23T22:55:05Z",
      "closedAt": "2023-01-23T22:55:05Z",
      "comments": []
    },
    {
      "number": 47,
      "id": "I_kwDOH6Ln3M5cdM8P",
      "title": "Draft 02: Revise UUID Generator States section",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/47",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 6.3, paragraph 2: \"it can always say that the values were\r\nunavailable\" It says this in what way? For example, does it return an exception? Should there be normative language for this?\r\n\r\nKyzer\r\n> This entire section of text is from \"4.2.1.1.  Reading Stable Storage\", \"4.2.1.3.  Writing Stable Storage\", and \"Sharing State Across Processes\"\r\nI agree, the text in this section needs some massaging. \r\nFurther, when I was porting RFC4122 into the new layout this text was somewhat out of place, but I didn't want to drop any text without first consulting the working group.\r\nI will create a tracker to go over that section and make sure it meshes well with the rest of the doc or remove that section completely if it no longer is relevant.",
      "createdAt": "2023-01-20T16:46:50Z",
      "updatedAt": "2023-02-16T22:14:24Z",
      "closedAt": "2023-02-16T22:14:24Z",
      "comments": []
    },
    {
      "number": 48,
      "id": "I_kwDOH6Ln3M5cdNhb",
      "title": "Remove IEEE paragraph from \"uuids that do not identify the host\"",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/48",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "As per Jim not required in this document since we are discouraging centralized registries and IEEE mac addresses.\r\n> One approach is to contact the IEEE and get a separate block of addresses. At the time of writing, the application could be found at https://standards.ieee.org/products-programs/regauth/.",
      "createdAt": "2023-01-20T16:48:31Z",
      "updatedAt": "2023-01-23T22:55:05Z",
      "closedAt": "2023-01-23T22:55:05Z",
      "comments": []
    },
    {
      "number": 49,
      "id": "I_kwDOH6Ln3M5cdNsz",
      "title": "Draft 02: Further Clarify that non-descript node IDs are the preferred method in distributed UUID Generation",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/49",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 6.4, last paragraph: \"two aforementioned\": please name them.\r\n\r\nKyzer:\r\n> This sentence should go or at least point to non-descript node identifiers vs both methods. (Another Tracker item)",
      "createdAt": "2023-01-20T16:49:03Z",
      "updatedAt": "2023-02-16T22:14:24Z",
      "closedAt": "2023-02-16T22:14:24Z",
      "comments": []
    },
    {
      "number": 50,
      "id": "I_kwDOH6Ln3M5cdQUr",
      "title": "Discussion: SHA256 UUID Generation",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/50",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "### Topic from Interim:\r\n- How does one create a Name-based UUID if MD5 or SHA1 are deprecated from a library/implementation, not available or otherwise deemed unsecure and cannot be utilized?\r\n\r\n### Restrictions:\r\n- Can't modify v5 to be SHA256. It must remain untouched.\r\n\r\n### Ideas\r\n#### UUIDv9 (SHA256 Based UUID) \r\n- Totally Feasible as per https://github.com/ietf-wg-uuidrev/rfc4122bis/blob/main/editor-files/UUIDv3-\r\nv5-Testing.md?plain=1#L132\r\n- Ties up a new version in a type of UUID that is:\r\n  - \"Not widely utilized or even implemented in many libraries.\" - Kyzer/Brad\r\n  - \"Studies showed name-based UUIDs made up something like 1% of use cases\" - Robert\r\n  - \"Energy in previous draft was on time-based UUIDs and there was little to no discussion on name-based other than the original documents descriptions around these particular UUIDs is confusing\" - Kyzer\r\n\r\n#### Add Text and steer towards v8 as a use case\r\n- Paragraph or sentence that says if SHA256 is desired for any reason then the UUIDv5 steps can be utilized but the version must be incremented to v8 to utilize the experimental, vendor-specific implementation space\r\n- Consensus achieved on this proposal for steering text. Slated for Draft 02",
      "createdAt": "2023-01-20T16:56:40Z",
      "updatedAt": "2023-02-16T22:14:24Z",
      "closedAt": "2023-02-16T22:14:24Z",
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "> Add Text and steer towards v8 as a use case\r\n\r\n+1",
          "createdAt": "2023-01-20T23:04:08Z",
          "updatedAt": "2023-01-20T23:04:08Z"
        },
        {
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The problem I have using v8 for this is some of the use cases that were discussed for SHA1 and MD5: the desire for two nodes with the same object to be hashed to arrive at the same UUID. While it's possible to do this with v8 by prior arrangement, there must be a reason to have v3 and v5 specify the hash algorithm they use. One reason I can think of is if there is a future transition away from SHA256 to something else and it's important during a transition to know what UUIDs are generated with SHA256 and which with the newer algorithm.",
          "createdAt": "2023-02-01T04:50:10Z",
          "updatedAt": "2023-02-01T04:50:10Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was wondering if we can/should pick some new vX, allocate 4 -bits to hash type, and put SHA256 there.\r\n(I also wonder if there is a way to wedge that into v3 or v5, but there probably isn't)\r\n",
          "createdAt": "2023-02-01T19:41:56Z",
          "updatedAt": "2023-02-01T19:41:56Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcr, @jimfenton: I thought about this a bit over the weekend and here are my thoughts summarized nicely.\r\n\r\n### Deprecate SHA1 and replace it with SHA256 as the \"new\" v5\r\n**Pro**: Avoids new version, removes security considerations around SHA1.\r\n**Cons**: Forces legacy implementations to 'not RFC compliant' if they are old, lack compute. Furthermore, who the application using an existing v5 name may not be able to update the name across the application context very easily. \r\n**Other**: We opted to not replace v1 when we made v6, so I would be hesitant to replace v5 like this.\r\n\r\n### Cram SHA256 into v5\r\n**Pro**: Avoids new version, removes security considerations around SHA1.\r\n**Cons**:  Muddies v5 and can lead to some confusing scenarios where two peers calculate different outputs where one assumed SHA1v5 and one assumed SHA256v5.\r\n**Other**: To clarify, one such hypothetical scenario could be where Alice uses raw inputs to calculate a UUIDv5 and produced sha256-based output as an input to feed into some other application logic for further output computation. (Think some identity-name-based style HMAC like HTTP/SIP use). Then the Bob uses the same inputs, calculates a v5 sha1-based UUIDv5, feeds it into the same algo to further the process. The result is two outputs that differ and who knows what problem that causes. This is all assuming there are no out of band method to say \"use sha256 and not sha1\" etc.\r\n\r\n### Leverage SHA256 with v8\r\n**Pro**: Leaves SHA1 UUIDs and implementations to operate how they have for the past 20 years.\r\n**Cons**: Possibly cause issues when SHA256 v8 co-exist with other UUIDv8s? Personally I don't think that is an issue; if we are doing name-based UUIDs in v8 there is likely some application logic shared between systems to know what algo to use in the first place (sha256 or some other like sha384 or even some next-gen quantum crypto hash algos). \r\n**Other**: To further clarify, the overlap of some other specific v8 time-based algo, some name-based algo or even that one guy who creates UUIDs that only contain readable words are not a problem. This is because in the grand scheme of the application context this use case for v8 likely wouldn't overlap or really inhibit another v8 implementations using them in some other manner. Basically UUIDv8 are really good within your application but are not guaranteed to the greater world by their design.\r\n\r\n### Allocate v9 for SHA256\r\n**Pro**: Removes security considerations around SHA1 (can discourage v5 use and point v3 and v5 at v9). No ambiguity about usage.\r\n**Cons**: Likely to not be implemented very widespread, ties up a version (0 and 10-15 would be the only ones left). What do we do when somebody wants to use SHA384 or some some next-gen quantum crypto hash algos? Seems like a slippery slope I would like to avoid.",
          "createdAt": "2023-02-06T15:19:44Z",
          "updatedAt": "2023-02-06T15:19:44Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Kyzer Davis ***@***.***> wrote:\n    > ### Allocate v9 for SHA256\n\nAllocate v9 for all-future hashes, with a hash-subtype.\n\n",
          "createdAt": "2023-02-06T17:41:22Z",
          "updatedAt": "2023-02-06T17:41:22Z"
        },
        {
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mcr That's also the direction I was thinking, although I don't have any first-hand knowledge on how these UUID versions are used.",
          "createdAt": "2023-02-06T17:48:31Z",
          "updatedAt": "2023-02-06T17:48:31Z"
        },
        {
          "author": "ramsey",
          "authorAssociation": "NONE",
          "body": "@mcr @jimfenton I came here to say the same thing. Perhaps some set of bits can be allocated as a hash ID. We would need to create a registry of hash IDs, and depending on the number of bits allocated for the hash ID, we'd be limiting the number of future hashes that could be added to the registry. In practice, this might never become an issue.",
          "createdAt": "2023-02-06T20:19:35Z",
          "updatedAt": "2023-02-06T20:19:35Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "One possible approach I'd suggest:\r\n\r\n### Predefine hash algorithm UUIDs and prepend one to name space ID and name\r\n\r\n```python\r\nimport hashlib\r\nimport uuid\r\n\r\n\r\n# predefined by RFC 4122\r\nNAMESPACE_DNS = uuid.UUID(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")\r\n\r\n# predefined by new RFC (UUIDv4s I just made up for example)\r\nALGORITHM_SHA256 = uuid.UUID(\"3fb32780-953c-4464-9cfd-e85dbbe9843d\")\r\nALGORITHM_SHA512 = uuid.UUID(\"e6800581-f333-484b-8778-601ff2b58da8\")\r\n\r\n\r\n# concatenate hash_algorithm_uuid + namespace_uuid + name; then hash\r\nsha256 = hashlib.new(\"sha256\")\r\nsha256.update(ALGORITHM_SHA256.bytes)\r\nsha256.update(NAMESPACE_DNS.bytes)\r\nsha256.update(b\"example.com.\")\r\nprint(\"SHA-256:\", sha256.hexdigest()[0:32], \"(truncated)\")\r\n\r\n# ditto\r\nsha512 = hashlib.new(\"sha512\")\r\nsha512.update(ALGORITHM_SHA512.bytes)\r\nsha512.update(NAMESPACE_DNS.bytes)\r\nsha512.update(b\"example.com.\")\r\nprint(\"SHA-512:\", sha512.hexdigest()[0:32], \"(truncated)\")\r\n\r\n# output:\r\n# SHA-256: 564315c658dc181edb907cfa7d55605b (truncated)\r\n# SHA-512: b096e1610da091aa73cdfe4d1132a5aa (truncated)\r\n```\r\n\r\nThis approach ensures that the inputs to hash algorithms are unique per algorithm no matter what the namespace and name are, though such consideration could be meaningless for collision resistance because different hash algorithms are expected to produce very different sequences of bytes.\r\n\r\nThis approach doesn't allow us to identify the hash algorithm used by a given name-based UUID, but I'm not convinced that such reverse engineering is really necessary. It is anyway not possible to reproduce a name-based UUID without knowledge of the namespace ID and the original name, and with such knowledge, it is quite easy to determine the hash algorithm by trying all the few common algorithms. For the same reason, I am skeptical about allocating dedicated hash ID bits in the precious 128-bit space, especially when we have a different idea to guarantee uniqueness.\r\n",
          "createdAt": "2023-02-07T00:20:02Z",
          "updatedAt": "2023-02-07T00:20:02Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What @LiosK works for me.  I just think that we will get pushback if we don't provide a way to use newer hashes in a deterministic way.  I'm unclear what version would be used for the above approach.",
          "createdAt": "2023-02-07T10:06:53Z",
          "updatedAt": "2023-02-07T10:06:53Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "Although I don't have a strong opinion here, I believe a new name-based scheme is not worth a new version and should stay in the v8 because I'd totally agree with the points quoted by Kyzer:\r\n\r\n> - \"Not widely utilized or even implemented in many libraries.\" - Kyzer/Brad\r\n> - \"Studies showed name-based UUIDs made up something like 1% of use cases\" - Robert\r\n> - \"Energy in previous draft was on time-based UUIDs and there was little to no discussion on name-based other than the original documents descriptions around these particular UUIDs is confusing\" - Kyzer\r\n\r\nA standard makes sense only when it coordinates multiple implementations to interoperate with each other. It might logically look flawed to define deprecated algorithm-based v3 and v5 only, but, if there are few people wishing for an updated name-based scheme, it wouldn't be really helpful to introduce a new standard just to fix the _flaw_.\r\n\r\nPlus, v3 and v5 used to be the only mechanisms that could incorporate application-specific ID (name) schemes into the UUID space, but now we have v8 and can include whatever application-specific information in a UUID. I'd anticipate fewer use cases of v3 and v5 after the introduction of v8.\r\n\r\nI'm also concerned about the inactive discussion so far over name-based schemes. I'm not even sure if truncating hash digests is a safe, secure, and valid approach to produce a universally unique identifier.\r\n\r\nAnyway, we can perhaps add the discussion here to the best practice section and see if new name-based practices emerge.",
          "createdAt": "2023-02-07T12:44:57Z",
          "updatedAt": "2023-02-07T12:44:57Z"
        },
        {
          "author": "ramsey",
          "authorAssociation": "NONE",
          "body": "> I'm not even sure if truncating hash digests is a safe, secure, and valid approach to produce a universally unique identifier.\r\n\r\nI've often wondered this about v5. Introducing even longer hashes probably stands a greater chance of seeing repeating characters at the beginning of the hash, especially with the truncation involved to fit within 128 bits, though I'm no expert on hashing algorithms.",
          "createdAt": "2023-02-07T15:14:42Z",
          "updatedAt": "2023-02-07T15:14:42Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't object to v3/v5: they were in rfc4122, and were current at the time.\r\nBut, we need to be clear that there is a way to use newer hashes in a deterministic way.  @LiosK 's suggestion, as a v8 method works for me.. Please just add two paragraphs somewhere about how to do that.  Not sure we need python code, but I don't object to it.",
          "createdAt": "2023-02-07T17:25:45Z",
          "updatedAt": "2023-02-07T17:25:45Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Just caught up on the thread. \r\n\r\nLet me take a pass tomorrow at implementing some text around what @LiosK discussed so we can add some \"best practice\" logic to future hash based UUIDs in v8 bit space.\r\n\r\nAlso, @ramsey, totally agree. SRTP went with an approach back in the day of truncating the SHA to 32 or 80 length for the early SRTP Crypto Suites and they updated that when they added new algos: https://www.rfc-editor.org/rfc/rfc7714#section-13.2\r\nSomewhat unrelated to the context but just one such example that comes to mind. \r\n\r\nPerhaps when I get back to `UUID Long` we can provide an alternative which do not need to be truncated:\r\nhttps://uuid6.github.io/new-uuid-encoding-techniques-ietf-draft/draft-00/#name-uuid-long",
          "createdAt": "2023-02-07T19:20:05Z",
          "updatedAt": "2023-02-07T19:24:05Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "By the way, it's interesting that [FIPS 180-4](https://csrc.nist.gov/publications/detail/fips/180/4/final) (SHA-1 and SHA-2 standard) explicitly permits to take leftmost bits of a message digest:\r\n\r\n> Some application may require a hash function with a message digest length different than those provided by the hash functions in this Standard. In such cases, a truncated message digest may be used, whereby a hash function with a larger message digest length is applied to the data to be hashed, and the resulting message digest is truncated by selecting an appropriate number of the leftmost bits. For guidelines on choosing the length of the truncated message digest and information about its security implications for the cryptographic application that uses it, see SP 800-107 [SP 800-107].\r\n\r\nI'm not sure if the same discussion applies to SHA-3 as well. Plus, [FIPS 180-4 is currently under review for revision](https://csrc.nist.gov/News/2022/proposal-to-revise-fips-180-4-secure-hash-standard), and [some public comments expressed concern about truncation](https://csrc.nist.gov/csrc/media/projects/crypto-publication-review-project/documents/initial-comments/fips180-4-initial-public-comments-2022.pdf). So, this section of FIPS 180-4 might not survive in FIPS 180-5, but probably we can find some useful discussion about digest truncation around FIPS 180-4 resources.\r\n\r\nEdit: Perhaps, we should also take a look at [SP 800-90A](https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final) to deep dive into name-based schemes. If we can derive 122-bit random (statistically independent and unbiased) data from a name in a deterministic manner, then we can construct a UUID from the random bits. SP 800-90A discusses deterministic random bit generators (DRBGs) and SHA-1/2 functions as building blocks of DRBGs.",
          "createdAt": "2023-02-08T11:28:21Z",
          "updatedAt": "2023-02-08T13:04:09Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "My preference: Cite that NIST [SP 800-90A](https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final) document as another resource for using random in applications properly in our later sections.\r\n\r\n---\r\n\r\nOn the FIPS180-4 comment: We could cite at least FIPS 180-4 as something that allows truncation at least in those versions. If they don't want to truncate guide towards v8 (which also covers us if they disallow truncating down the road.) ",
          "createdAt": "2023-02-08T15:33:50Z",
          "updatedAt": "2023-02-08T15:33:50Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "Oh, I didn't mean the RFC should reference SP 800-90A. I was just like saying: if we were to develop a new name-based scheme seriously, we would have to prove that the new scheme guaranteed the universal uniqueness of the outputs, and the NIST doc would be helpful for that.\r\n\r\nAt a glance, SP 800-90A seems to rely on truncated hash digests as a source of random (i.e., statistically independent and unbiased) sequences of bits. If so (I mean, if each SHA function produces leading 122 bits in a statistically independent and unbiased manner), the approach I suggested previously will produce universally unique IDs even if it truncates digests and mixes the results from multiple SHA functions in one 128-bit ID space.",
          "createdAt": "2023-02-08T18:50:51Z",
          "updatedAt": "2023-02-08T18:50:51Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed up https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/83d95da3418a92a13dfa5222c30795244f24f565\r\n\r\nThis contains:\r\n- Forward reference to best practices section on how to actually create one of these values\r\n- A quick comment on name space best practice to hit #53 topic to allow implementers to allow custom input rather than just the ones we put have in the appendix.\r\n- A section on how to create a v8 UUID with hashspace+namespace+name and desired hash of choice.\r\n- An appendix with every modern SHA2/SHA3/SHAKE algo with a random v4 UUID allocated as a hashspace  (md5 and sha1 omitted)\r\n- A name-based v8 test vector for SHA2-256 hashspace + DNS namespace +  www.example.com\r\n- Renamed old v8 test vector to be time-based to better distinguish these two.\r\n\r\nTesting:\r\n- Used my awful bash script.\r\n- A delta of @LiosK python code to use input of `www.example.com` rather than `example.com.` to be consistent with the MD5 and SHA1 test vectors. \r\n  - I also changed the `bytes(\"www.example.com\", \"utf-8\")` since that is what the official [python library](https://github.com/python/cpython/blob/main/Lib/uuid.py#L728) does although I saw not observable difference.\r\n- Those tests are in the `UUIDv3-v5-Testing.md` file also in the commit.\r\n- Both output the same starting sha256 which is the only item I was trying to verify.",
          "createdAt": "2023-02-09T20:56:20Z",
          "updatedAt": "2023-02-09T20:56:20Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "Looks awesome!\r\n\r\nCould sound obvious, but I think we should add some clarifying text to the Some Hash Space IDs section saying like when using SHAKE_128 or SHAKE_256, implementations must extract at least 128 bits for a digest, because these variable length algorithms may technically produce a digest shorter than 128 bits.",
          "createdAt": "2023-02-10T00:26:46Z",
          "updatedAt": "2023-02-10T00:26:46Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK, \r\n\r\nUnderstood, I was not aware they are variable rate!\r\nI totally missed that last night looking at the SHA table here:\r\nhttps://en.wikipedia.org/wiki/Secure_Hash_Algorithms\r\n\r\nEdit, updated as per https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/60/commits/b094dfc0f75f53d8f3d63f9daccb8a3e3614959f",
          "createdAt": "2023-02-10T14:34:06Z",
          "updatedAt": "2023-02-10T14:55:48Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Question from @jimfenton on Interim: \r\n> Should we remove \"or larger?\" \r\n> Does SHAKE-128 output of 128 differ from SHAKE-128 with output of 256\"\r\n\r\nDraft 02 Proposed Text:\r\n> An important note for secure hashing algorithms that produce variable rate outputs, such as those found in SHAKE, the output hash MUST be 128 bits or larger.\r\n\r\n### Testing\r\nThe first 128 bits that we are about are always the same and do not change even if you request an output of more bits. \r\nSo it can be at or larger and be okay\r\nTested using online tool, with openSSL+bash and cited from the original doc below.\r\nSo we should be okay to keep the text \"the output hash MUST be 128 bits or larger.\"\r\n\r\n### SHAKE-128\r\nhttps://emn178.github.io/online-tools/shake_128.html\r\n```\r\nInput: Hello World\r\n128: 1227c5f882f9c57bf2e3e48d2c87eb20\r\n256: 1227c5f882f9c57bf2e3e48d2c87eb20f382a4b639b54d26f6d595ff3db9064d\r\n```\r\n\r\n```\r\nkydavis@ubuntu-22:~$ echo -n \"Hello World\" | openssl dgst -SHAKE128\r\nSHAKE-128(stdin)= 1227c5f882f9c57bf2e3e48d2c87eb20\r\n```\r\n\r\n### SHAKE-256\r\nhttps://emn178.github.io/online-tools/shake_256.html\r\n```\r\nInput: Hello World\r\n128: 840d1ce81a4327840b54cb1d419907fd\r\n256: 840d1ce81a4327840b54cb1d419907fd1f62359bad33656e058653d2e4172a43\r\n```\r\n\r\n```\r\nkydavis@ubuntu-22:~$ echo -n \"Hello World\" | openssl dgst -SHAKE256\r\nSHAKE-256(stdin)= 840d1ce81a4327840b54cb1d419907fd1f62359bad33656e058653d2e4172a43\r\n```\r\n\r\n### Source:\r\nhttps://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf\r\nA.2 Additional Consideration for Extendable-Output Functions\r\n\r\n> By design, the output length for an XOF does not affect the bits that it produces\r\n\r\n> Consequently, when two different output lengths are\r\nchosen for a common message, the two outputs are closely related: the longer output is an\r\nextension of the shorter output.",
          "createdAt": "2023-02-16T21:24:29Z",
          "updatedAt": "2023-02-16T21:24:29Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOH6Ln3M5cdWNz",
      "title": "Draft 01: Change SHA references in v5 to SHA1",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/51",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "As per Interim Meeting consensus on:\r\nWhere SHA_SOME_FIELD_DESCRIPTOR change to SHA1_SOME_FIELD_DESCRIPTOR\r\n\r\n",
      "createdAt": "2023-01-20T17:14:33Z",
      "updatedAt": "2023-01-20T18:29:02Z",
      "closedAt": "2023-01-20T18:29:02Z",
      "comments": []
    },
    {
      "number": 52,
      "id": "I_kwDOH6Ln3M5cdrEn",
      "title": "Draft 01: Grammar Review",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/52",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Jim provided many changes for grammatical issues.\r\nTracking them via this Issue.",
      "createdAt": "2023-01-20T18:30:00Z",
      "updatedAt": "2023-01-20T18:40:21Z",
      "closedAt": "2023-01-20T18:40:21Z",
      "comments": []
    },
    {
      "number": 53,
      "id": "I_kwDOH6Ln3M5cdzj6",
      "title": "Discussion: Alternative Namespaces for Name-Based UUID",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/53",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "We have DNS, URL, OID, and X500 as per RFC4122: https://www.rfc-editor.org/rfc/rfc4122#appendix-C\r\n\r\n```\r\nDNS  = 6ba7b810-9dad-11d1-80b4-00c04fd430c8\r\nURL  = 6ba7b811-9dad-11d1-80b4-00c04fd430c8\r\nOID  = 6ba7b812-9dad-11d1-80b4-00c04fd430c8\r\nX500 = 6ba7b814-9dad-11d1-80b4-00c04fd430c8\r\n```\r\n\r\nThese are basically \"special case\" UUIDv1 values incremented at the last octet of the `time_low`.\r\nSee: https://stackoverflow.com/questions/7724903/where-do-uuid-namespaces-come-from\r\n\r\nFrom what I can see UUIDv3 and UUIDv5 Libraries will only implement what we define in the spec and do not allow for any inputs other than these four.\r\n\r\nSome common use cases that come to mind for UUIDs where a \"namespace\" may need to be defined are:\r\n- IOT applications\r\n- Database applications\r\n\r\nDoes it make sense to add the following by incrementing to `6ba7b814` to `6ba7b815` and `6ba7b816`\r\n```\r\nIOT = 6ba7b815-9dad-11d1-80b4-00c04fd430c8\r\nDB  = 6ba7b816-9dad-11d1-80b4-00c04fd430c8\r\n```",
      "createdAt": "2023-01-20T19:05:39Z",
      "updatedAt": "2023-02-16T22:14:25Z",
      "closedAt": "2023-02-16T22:14:25Z",
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "NONE",
          "body": "A little bit confused because IOT or DB doesn't look like a \"namespace\" (neither does X500 though). I think each IOT/DB/whatever application should generate a UUID and use it as its own application-specific namespace ID. For example:\r\n\r\n```python\r\nDB_APP_A_USER_ID_SPACE = \"c8158cdd-8ad5-477c-ab51-57703a54d286\"  # v4 I made up just now\r\nDB_APP_B_USER_ID_SPACE = \"a79c6917-619f-4e8c-abcf-170a6116878d\"  # ditto\r\n\r\nuuidv5_a = gen_uuidv5(name_space_id=DB_APP_A_USER_ID_SPACE, name=\"LiosK\")\r\nuuidv5_b = gen_uuidv5(name_space_id=DB_APP_B_USER_ID_SPACE, name=\"LiosK\")\r\n```\r\n\r\nA predefined namespace ID that might be shared by multiple applications/namespaces doesn't seem useful here.",
          "createdAt": "2023-01-21T01:28:20Z",
          "updatedAt": "2023-01-21T01:28:20Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK, while that should be true, the point I was making is that almost no library implements a \"generic enter your own namespace\" option. Where most are hardcoded to whatever is in RFC4122.\r\n\r\nThis at least gives a few more options, although probably not needed at all. I just wanted to at least bring it up while revising the spec.",
          "createdAt": "2023-01-23T21:09:15Z",
          "updatedAt": "2023-01-23T21:09:15Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I opted to add some text around the topic of allowing custom inputs for namespace rather than JUST what is in the document without adding any new items.",
          "createdAt": "2023-02-09T20:57:33Z",
          "updatedAt": "2023-02-09T20:57:33Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOH6Ln3M5coA9o",
      "title": "Draft 02: Appendix B, consistent naming",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/55",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Need to change to \"Example of a UUIDvX Value\" some are missing an A\r\n```\r\nAppendix B.  Test Vectors\r\nB.1.  Example of UUIDv1 Value\r\nB.2.  Example of UUIDv3 Value\r\nB.3.  Example of UUIDv4 Value\r\nB.4.  Example of UUIDv5 Value\r\nB.5.  Example of a UUIDv6 Value\r\nB.6.  Example of a UUIDv7 Value\r\nB.7.  Example of a UUIDv8 Value\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2023-01-23T23:25:49Z",
      "updatedAt": "2023-02-16T22:14:25Z",
      "closedAt": "2023-02-16T22:14:25Z",
      "comments": []
    },
    {
      "number": 56,
      "id": "I_kwDOH6Ln3M5coBUM",
      "title": "Draft 02: Remove duplicate ABNF from IANA considerations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/56",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "I thought I did this in Draft 01 but I believe I stashed my changes while fixing some merge conflicts. \r\nIANA ABNF should just refer to section 4 ABNF and we can reduce some verbiage in that template as per January Interim meeting.",
      "createdAt": "2023-01-23T23:27:45Z",
      "updatedAt": "2023-02-16T22:14:25Z",
      "closedAt": "2023-02-16T22:14:25Z",
      "comments": []
    },
    {
      "number": 57,
      "id": "I_kwDOH6Ln3M5coCjC",
      "title": "Draft 02: Monotonic Error Checking missing newline",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/57",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Markdown template is wrong, newline is missing to match the other min-sections styled in a specific way within this section.",
      "createdAt": "2023-01-23T23:34:47Z",
      "updatedAt": "2023-02-16T22:14:26Z",
      "closedAt": "2023-02-16T22:14:26Z",
      "comments": []
    },
    {
      "number": 59,
      "id": "I_kwDOH6Ln3M5dAc6p",
      "title": "Draft 02: Change md5_high in SHA1 section to sha1_mid",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/59",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "```\r\nsha1_mid:\r\n12 more bits of the layout consisting of the least significant, right-most 12 bits of 16 bits immediately following md5_high from the computed SHA1 value.\r\n```\r\n\r\n```\r\nsha1_mid:\r\n12 more bits of the layout consisting of the least significant, right-most 12 bits of 16 bits immediately following sha1_high from the computed SHA1 value.\r\n```",
      "createdAt": "2023-01-27T20:34:19Z",
      "updatedAt": "2023-01-31T23:05:26Z",
      "closedAt": "2023-01-31T23:05:26Z",
      "comments": [
        {
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WG rough consensus isn't needed to correct an obvious cut-and-paste error like this. Go ahead and fix.",
          "createdAt": "2023-01-27T20:39:33Z",
          "updatedAt": "2023-01-27T20:39:33Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOH6Ln3M5eF87D",
      "title": "Draft 02: Clean up text in UUIDs that Do Not Identify the Host",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/61",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Just needs a bit ironed out, the current text is a copy from 4122 similar to #47 \r\n\r\nMaybe cite a reference to the Multicast bit too?",
      "createdAt": "2023-02-09T21:04:40Z",
      "updatedAt": "2023-02-16T22:14:26Z",
      "closedAt": "2023-02-16T22:14:26Z",
      "comments": []
    },
    {
      "number": 62,
      "id": "I_kwDOH6Ln3M5eqzGF",
      "title": "Delete Sample Code Appendix",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/62",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "As per Interim not required and changing v1-5 to decouple from multiplexed fields is a fair ammount of work opening us to potential errata.\r\n\r\nTest Vectors will remain.",
      "createdAt": "2023-02-16T19:54:20Z",
      "updatedAt": "2023-02-16T22:14:27Z",
      "closedAt": "2023-02-16T22:14:27Z",
      "comments": []
    },
    {
      "number": 64,
      "id": "I_kwDOH6Ln3M5hCKuX",
      "title": "Draft 03: Fix idnits errors and warnings",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/64",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "- 5 Errors\r\n- 10 Warnings\r\n\r\nhttps://author-tools.ietf.org/",
      "createdAt": "2023-03-16T17:28:40Z",
      "updatedAt": "2023-04-11T13:53:57Z",
      "closedAt": "2023-04-11T13:53:57Z",
      "comments": []
    },
    {
      "number": 65,
      "id": "I_kwDOH6Ln3M5hCMeS",
      "title": "Draft 03: Add other Hash Abbreviations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/65",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Jim:\r\n\r\n> Section 3.2 defines MD5 and SHA1, but not any of the other hashes referenced in the document.",
      "createdAt": "2023-03-16T17:32:45Z",
      "updatedAt": "2023-04-11T13:53:57Z",
      "closedAt": "2023-04-11T13:53:57Z",
      "comments": []
    },
    {
      "number": 66,
      "id": "I_kwDOH6Ln3M5hCOVF",
      "title": "Draft 03: Normalize SHA abbreviation formats",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/66",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "With or without dash:\r\n- SHA1\r\n- SHA-1\r\n\r\nFIPS documents use dash, will normalize our document to the same.",
      "createdAt": "2023-03-16T17:36:24Z",
      "updatedAt": "2023-04-11T13:53:58Z",
      "closedAt": "2023-04-11T13:53:58Z",
      "comments": []
    },
    {
      "number": 67,
      "id": "I_kwDOH6Ln3M5hCQEN",
      "title": "Draft 03: Fix \"integral numbers of octets\" verbiage",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/67",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Before: \r\n> To minimize confusion about bit assignments within octets and among differing versions, the UUID record definition is defined only in terms of fields that are integral numbers of octets. \r\n\r\nAfter:\r\n> To minimize confusion about bit assignments within octets and among differing versions, the UUID record definition is provided as a a grouping of fields within bit layout consisting four octets to a row.\r\n\r\nEdit: Updated grammar as per @cbandy comment.",
      "createdAt": "2023-03-16T17:41:34Z",
      "updatedAt": "2023-04-11T13:53:58Z",
      "closedAt": "2023-04-11T13:53:58Z",
      "comments": [
        {
          "author": "cbandy",
          "authorAssociation": "NONE",
          "body": "\"is provides as a a grouping\" \u2192 \"is provided as a grouping\", perhaps?\r\n\r\n\"consisting four octets octets\" \u2192 \"consisting of four octets\", perhaps?",
          "createdAt": "2023-03-18T16:01:00Z",
          "updatedAt": "2023-03-18T16:01:00Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDOH6Ln3M5hCSZR",
      "title": "Draft 03: Move Community Considerations to Introduction",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/68",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Fits nicely in between first and second paragraph to remove this non-standard section.",
      "createdAt": "2023-03-16T17:48:25Z",
      "updatedAt": "2023-04-11T13:53:59Z",
      "closedAt": "2023-04-11T13:53:59Z",
      "comments": []
    },
    {
      "number": 69,
      "id": "I_kwDOH6Ln3M5hCTZQ",
      "title": "Draft 03: Reference all Hash Algorithms.",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/69",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "",
      "createdAt": "2023-03-16T17:51:02Z",
      "updatedAt": "2023-04-11T13:53:59Z",
      "closedAt": "2023-04-11T13:53:59Z",
      "comments": []
    },
    {
      "number": 70,
      "id": "I_kwDOH6Ln3M5hCT36",
      "title": "Draft 03: Transpose UUID Namespaces to match UUID Hashspaces",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/70",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Remove the C structs and make them text.",
      "createdAt": "2023-03-16T17:52:14Z",
      "updatedAt": "2023-04-11T13:54:00Z",
      "closedAt": "2023-04-11T13:54:00Z",
      "comments": []
    },
    {
      "number": 72,
      "id": "I_kwDOH6Ln3M5h3DZl",
      "title": "provide definition for uuid_t, or do not use it",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/72",
      "state": "CLOSED",
      "author": "mcr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "We either need to put the typedef back in for uuid_t, or we need to make just write the uuid like we do in appendix B.\r\n",
      "createdAt": "2023-03-27T10:14:31Z",
      "updatedAt": "2023-04-05T13:26:16Z",
      "closedAt": "2023-04-05T13:26:15Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, recorded under #70 where I will make it all text and remove the C code.",
          "createdAt": "2023-03-27T19:49:53Z",
          "updatedAt": "2023-03-27T19:49:53Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOH6Ln3M5izEQN",
      "title": "Draft 03: Remove URN from title",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/73",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "The URN in the title is out of place as the entire document defines UUIDs and their many usages. URN is one such (small) part of the greater document.\r\n",
      "createdAt": "2023-04-06T14:40:05Z",
      "updatedAt": "2023-04-11T13:54:01Z",
      "closedAt": "2023-04-11T13:54:01Z",
      "comments": []
    },
    {
      "number": 74,
      "id": "I_kwDOH6Ln3M5izH9j",
      "title": "Draft 03: Move some Normative Reference to Informative",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/74",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "",
      "createdAt": "2023-04-06T14:48:09Z",
      "updatedAt": "2023-04-11T13:54:01Z",
      "closedAt": "2023-04-11T13:54:01Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Unsure how to handle these in IDNITS checks:\r\n```\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'C309'\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'C311'\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'FIPS180-4'\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'FIPS202'\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'RANDOM'\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'X667'\r\n```",
          "createdAt": "2023-04-06T15:57:38Z",
          "updatedAt": "2023-04-06T15:57:38Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOH6Ln3M5izmYM",
      "title": "Draft 03: Downgrade MUST NOT to SHOULD NOT for guessability of UUIDs",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/75",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "> Section 9, \u201cImplementations MUST NOT assume that UUIDs are hard to guess.\u201d \r\n> This would mean that it\u2019s not permissible to use a randomly generated UUID for something like a session cookie. \r\n> On the other hand, NIST currently considers a random value generated \r\n> from a CSPRNG with a security  strength of at least 112 bits to be \r\n> effectively unguessable (see SP 800-131A), and a version 4 UUID meets that requirement. This prohibition seems a little strong.\r\n\r\nThis is the RFC4122 verbiage but we could downgrade to a SHOULD NOT. \r\n",
      "createdAt": "2023-04-06T16:05:33Z",
      "updatedAt": "2023-04-11T13:54:02Z",
      "closedAt": "2023-04-11T13:54:02Z",
      "comments": [
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that if someone needs something that is hard to guess, they need to be responsible for making sure.\r\nI think that the point of this disclaimer is that not all UUIDs are hard to guess, and we don't want people confused.",
          "createdAt": "2023-04-06T19:21:10Z",
          "updatedAt": "2023-04-06T19:21:10Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDOH6Ln3M5lt0-8",
      "title": "List of remarks of current draft 03",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/83",
      "state": "CLOSED",
      "author": "ben221199",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I have read the whole specification from top to bottom and this are my remarks with the current version of the draft:\r\n\r\n---\r\n\r\n1.\t> P. Leach\r\n\t> Microsoft\r\n\r\n\tI tried to contact P. Leach to talk about UUID, but his mail paulle@microsoft.com doesn't work anymore, as it seems. Is he involved in the project? Else, should he be removed from the header?\r\n\r\n---\r\n\r\n2.\t> This specification defines a Uniform Resource Name namespace for UUIDs (Universally Unique IDentifiers), also known as GUIDs (Globally Unique IDentifiers).\r\n\r\n\tI would write this in another way, because the RFC is in the first place a RFC about UUIDs, not about URNs, like RFC 4122. I would write something like this:\r\n\t> This specification defines the UUIDs (Universally Unique IDentifiers) and it's a Uniform Resource Name namespace. UUIDs are also known as GUIDs (Globally Unique IDentifiers).\r\n\r\n\tAlso:\r\n\t> The information here is meant to be a concise guide for those wishing to implement services using UUIDs, as URNs [RFC8141], or otherwise.\r\n\r\n\tTo:\r\n\t> The information here is meant to be a concise guide for those wishing to implement services using UUIDs, eventually in combination with URNs [RFC8141] or other.\r\n\r\n---\r\n\r\n3.\t> 3 .   [Snowflake] by Twitter\r\n\r\n\tMaybe worth noting that Discord uses the same technique, but with a changed start date. Not 1970, but 2015.\r\n\r\n---\r\n\r\n4.\tMake a clear difference between wire formats and representation formats, like in Section 4. In wire format we have the families/variants and versions. In the representation format we have the old Apollo Computer format, but also the hex-and-dash format, the format without dashes and the hex-and dash format with `{` and `}`. Maybe, in the near future more representation formats will be designed, but those will not conflict with the wire format and vice versa. In case of URN, only hex-and-dash is allowed. I think it is important to list all representation formats I just called and which one (the hex-and-dash one), is a recommended. Don't talk about variants, families and versions in the section about representation formats.\r\n\r\n---\r\n\r\n5.\tAs mentioned in (4), I would rename Section 4 to `Representation Format` and create a new Section 5 with `Wire format`. Sections like 4.1 will now be Section 5.1, etc.\r\n\r\n---\r\n\r\n6.\tI talked about the variant field in #16, because at the moment it is a mess of 3 bits. In case of versions we have a clear view of what we are talking about: just 4 bits with a range from 0 to 15, of which in RFC 4122 the versions 1 to 5 were used. However, for variants this is not the case. In my issue I stated to use 8 bits, while some others proposed 4 bits. Why 8 bits? Because the legacy UUID also used 8 bits. So, in that case implementing libraries for UUIDs will become more easy to build and to understand.\r\n\r\n---\r\n\r\n7.\tMake it loud and clear that versions are ONLY a invention for the `10x` variant (see how ugly I have to name my variant at the moment). I have seen implementations of UUID libraries that messed up variants and versions, because they didn't understand RFC 4122.\r\n\r\n---\r\n\r\n8.\t> As such the definition of these UUIDs are outside the scope of this specification.\r\n\r\n\tI would suggest trying to define as much as possible, including UUID version 2.\r\n\r\n---\r\n\r\n9.\t> 5.10.  Max UUID\r\n\r\n\tI still prefer Omni UUID. \ud83d\ude05\r\n\r\n---\r\n\r\n10.\t> For compatibility with earlier specifications, note that this document uses the unicast/multicast bit, instead of the arguably more correct local/global bit.\r\n\r\n\tBecause MAC addresses with the local/global bit set or not are both possible in a network. This is not the case with the unicast/multicast bit. One node cannot have a MAC address that multicasts to multiple nodes.\r\n\r\n---\r\n\r\n11.\t> 7 .  IANA Considerations\r\n\r\n\tWhat does this mean? I understand that listing UUIDs themselves is not useful, but listing variants/families and versions would be useful for preventing conflicting implementations. In my case, I would reconsider the decision.\r\n\r\n---\r\n\r\n12.\t> Implementations SHOULD NOT assume that UUIDs are hard to guess. Foe example, they MUST NOT be used as security capabilities (identifiers whose mere possession grants access). Discovery of predictability in a random number source will result in a vulnerability.\r\n\r\n\tTypo.\r\n\r\n---\r\n\r\n13.\tTell about the Apollo variant, found here: https://opensource.apple.com/source/CF/CF-299.35/Base.subproj/uuid.c.auto.html.\r\n\r\n---\r\n\r\n14.\tTell about the Microsoft variant, if Paul Leach is still involved.\r\n\r\n---\r\n\r\nThanks for reading. I'm curious about your findings.",
      "createdAt": "2023-05-11T20:35:29Z",
      "updatedAt": "2023-05-23T20:50:01Z",
      "closedAt": "2023-05-23T16:39:24Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "1. We decided to keep the original authors as we are re-using some of their text.\r\n2. Yeah, that is a good suggestion.\r\n3. I wasn't aware of Discord when I did my research a few years ago. Not sure it is worth adding extra references to that since we currently have enough to drive the point home\r\n4. Makes sense to add the UUID layout enclosed by curly brackets if that is in use out there in modern implementations. Do you have anything to cite other than the legacy UUID usage?\r\n5. Not sure I agree.\r\n6. _See Below._\r\n7. Can I change the table to \"The variant mapped to the versions specified in this document.\"?\r\n8. _See Below._\r\n9. :)\r\n10. I am not sure I follow what should be changed?\r\n11. I believe the main point is we don't need an IANA listing where this document can serve as the purpose. When there are many IETF documents on a given topic; I see more value in a centralized IANA registry summarizing the disperse documents.\r\n12. \"Foe example\" thanks, many have missed that one!\r\n13. Yeah, easy enough to cite it in some way perhaps in the variant table row 1.\r\n14. _See Below_\r\n\r\n---\r\n\r\n6, 8, 14.\r\nI do not believe the IETF wanted this document detail every UUID in every variant space outside of variant 10x. \r\nIf there are resources we can cite them like we do for Version 2, and the new NCS one posted above.\r\nI will defer to the WG chairs @mcr and @jimfenton since this would add significant segments of text, push back the deadlines by a significant ammount and introduce fragmented sources of information on those UUID implementations outside of IETFs span of control. Further we risk something getting out of sync assuming one of those decide to update since the RFC isn't the authoritative source of those UUID variant implementations.\r\n\r\nEdit: Just to re-iterate my opinion: I believe that the other legacy UUIDs outside of the `10x` variant should be in a historical/informational type RFC separate from this update to 4122. That is, assuming IETF has interest in compiling and detailing reference specs for those.",
          "createdAt": "2023-05-15T14:22:32Z",
          "updatedAt": "2023-05-15T16:34:52Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Hello Kyzer,\r\n\r\nThanks for your response. My response:\r\n\r\n1.\tOk\r\n2.\tOk\r\n3.\tNo problem if Discord isn't added/mentioned in text, but it is always considerable if it has any added value\r\n4.\tI am aware of the following representation types:\r\n\t- `550e8400-e29b-41d4-a716-446655440000`\r\n\t- `{550e8400-e29b-41d4-a716-446655440000}`\r\n\t- `550e8400e29b41d4a716446655440000`\r\n\t- `34dc23469000.0d.00.00.7c.5f.00.00.00` (Legacy format: https://www.ibm.com/docs/en/aix/7.1?topic=u-uuid-gen-command-ncs)\r\n\t- 128-bit integer (both signed and unsigned)\r\n\t- Binary (just 0 and 1)\r\n5.\tIt doesn't need to be exactly as I proposed, but I think it should be very clear to people that do read the RFC can quickly see that there is a wire format and a representation format and that they aren't necessary dependent on each other. The best way I can imagine is having two top-sections called `Wire format` and `Representation format` (or it could be a first level sub-section).\r\n6.\t*See below.*\r\n7.\tAre you talking about table 2? The name has enough information, but maybe you can change it to: `UUID versions (as subtype for UUID variant 10x) defined by this specification`\r\n8.\t*See below.*\r\n9.\tI'm serious \ud83d\ude02\r\n10.\tThere is a sentence in the specification that tells that the `local/global` would be more logical. However, I explain why they chose the other bit: because multicast addresses cannot exist in a network.\r\n11.\tI think I don't agree on that one. For example, in DNS we have record types. Every RFC that defines a new record type will also be listed by IANA, RFC mentioned in the 4th column: https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4. So, after all, you have a list of all types and the RFC they are defined in. Because of this, you will have no conflicts of using the same number. I think the same is happening with UUIDs. We have RFC 4122 that defines version 1 to version 5. The new specification will redefine those too, but will also define 3 additional versions: version 6, version 7 and version 8. This will look like the following table: ![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/12856904/a1b36012-1045-4d7e-a911-58d4b0555c5b)\r\n12.\tNo problem.\r\n13.\tIf it is somehow mentioned, I think that is at least something. I think it is better to tell about the format, instead of referring to some vague `.c` file.\r\n14.\t*See below.*\r\n\r\n---\r\n\r\n6.\t`v`\r\n8.\t`v`\r\n14.\tIn my opinion there should at least be some RFC that describes all the UUID variants, families, versions and representation formats. If that will be this specification or some other, I don't actually care. I only care about it happening one day. However, I have the feeling that, if make a new document and don't merge the history in the current draft, the historical draft should be released first, because that one tells the basis of UUID, where this draft then is based on. Defering things to IETF is good, so we will know their view on the issue. Keep in mind that if we do publish the historical RFC afterwards, we maybe have to release another RFC in the future that merges current specification and the historical one into one, eventually adding some more variants and versions. I am okay with that too, but maybe is also more work in the end.",
          "createdAt": "2023-05-15T16:53:05Z",
          "updatedAt": "2023-05-15T16:53:05Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@ben221199, majority of these made it into draft 04 around version variant sub-type being for this, some other formats of note, multicast-bit, modification of the abstract.\r\n\r\nI still left out citing legacy/historical versions except for the IBM_NCS format which was a one liner.\r\nI think together we can easily knock those out together as historical/info RFC w/IANA ask after we get this RFC across the finish line. I will whip something up and submit it to you for you to review when I am back from traveling.\r\n\r\nReview what I submitted to IETF under draft 04 and create a _new issue_ if I did not address items  2, 6, 7, 10 and 12 on your list appropriately.",
          "createdAt": "2023-05-23T17:12:59Z",
          "updatedAt": "2023-05-23T17:13:39Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Hi @kyzer-davis,\r\n\r\nThanks for making these changes. I had a look and the changes seemed good to me. Of course I will recreate a new issue when I come across some more improvements.\r\n\r\nI saw about the IBM NCS one. I think it is nicely done, so that people will understand that there are more representation formats. Maybe we have to tell te difference between UUID and GUID too. (Yes, there is a difference. Thanks Microsoft. *sigh*)\r\n\r\nIf you think making a historical RFC is better than merging it into this one, lets go for it. I already started something some months ago: https://github.com/yocto/draft-yocto-uuid.\r\n\r\nReview:\r\n\r\n1.\tFine.\r\n2.\tPerfect.\r\n3.\tI have some ideas about this.\r\n4.\tPerfect. Maybe add something about the difference between UUID and GUID.\r\n5.\tFine. Maybe a task for historical RFC.\r\n6.\tMaybe a task for historical RFC.\r\n7.\tPerfect.\r\n8.\tMaybe a task for historical RFC.\r\n9.\tNO. \ud83d\ude02\r\n10.\tPerfect.\r\n11.\tMaybe a task for historical RFC.\r\n12.\tPerfect.\r\n13.\tMaybe a task for historical RFC.\r\n14.\tMaybe a task for historical RFC.\r\n\r\nMost things are handled or will eventually be handled when having a historical RFC. I will create a new issue with the remaing points and maybe some new things.",
          "createdAt": "2023-05-23T20:47:51Z",
          "updatedAt": "2023-05-23T20:47:51Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOH6Ln3M5l7jXK",
      "title": "Draft 04: Move endianness statement from layout to format section",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/85",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> 2) Another remark, about byte order, perhaps the information of byte ordering should be moved from 5.  UUID Layouts to 4. UUID Format\r\nReading the section 4, you wonder about endianness and the info is quite far imho\r\n\r\nFrom: Aur\u00e9lien LAJOIE <orel@melix.net> via mailer.",
      "createdAt": "2023-05-15T13:29:29Z",
      "updatedAt": "2023-05-23T16:39:25Z",
      "closedAt": "2023-05-23T16:39:25Z",
      "comments": []
    },
    {
      "number": 86,
      "id": "I_kwDOH6Ln3M5l_n5q",
      "title": "Limiting size of additional clock precision (method 4) for v7",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/86",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(Copied from my email to uuidrev@ietf.org to add a relevant but different topic)\r\n\r\nI would propose to limit the size of Increased Clock Precision (6.2. Monotonicity and Counters: Method 4) to a certain number of bits, say 12 bits, for the UUIDv7 purpose. I really like the idea of the additional clock precision encoded using the fractional representation, but I'd like to point out a potential concern about universal uniqueness and usability.\r\n\r\nThe v7 scheme currently relies on randomness for universal uniqueness. On the other hand, a timestamp is not a source of randomness but is a shared piece of information across multiple generators. The timestamp field provides the universal uniqueness property by relying on the timing of generation, not randomness, so two timestamps collide if two generators generate IDs exactly at the same time, even if they employ picosecond timestamps. In other words, the timestamp and randomness both offer universal uniqueness but through different mechanisms.\r\n\r\nIn my opinion, UUIDv7 is more useful for users if the RFC sticks to the randomness mechanism to guarantee universal uniqueness. If the spec mixes the two mechanisms, then users have to take care of the timing of generations or the configuration of PRNGs depending on the implementation of a UUIDv7 generator, which introduces additional complexity to just get a time-ordered UUID. So, I believe the standard should limit the maximum size of extra clock precision to guarantee that a sufficient bit space is reserved for the randomness field.\r\n\r\nIt would be hard to set an appropriate limitation, but 12 bits might be a good starting point. By limiting the size of method 4 clock precision to 12 bits, we can guarantee the same level of randomness (62 bits) as UUIDv6 while accepting microsecond-precision timestamps. Applications that need finer timestamps are likely to be specialized use cases and should generally resort to UUIDv8.",
      "createdAt": "2023-05-16T03:52:23Z",
      "updatedAt": "2023-05-23T16:39:26Z",
      "closedAt": "2023-05-23T16:39:25Z",
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is it possible to replace the following text in Replace Left-Most Random Bits with Increased Clock Precision (Method 4):\r\n\r\n> Using floating point math, multiply this fraction of a millisecond value by <del>4095</del> and round to an integer result to arrive at a number between 0 and the maximum allowed for the indicated bits which is sorts monotonically based on time.\r\n\r\nWith:\r\n\r\n> Using floating point math, multiply this fraction of a millisecond value by <ins>4096</ins> and round <ins>down (toward zero)</ins> to an integer result to arrive at a number between 0 and the maximum allowed for the indicated bits which is sorts monotonically based on time.\r\n\r\nThe latter logic is expressed in Python as follows:\r\n\r\n```python\r\nsubmsec_float = 0.4567\r\nsubmsec_frac_bin_from_float = int(submsec_float * 0b1_0000_0000_0000)\r\n\r\nassert submsec_frac_bin_from_float == 1870\r\n```\r\n\r\nAnd, it allows the faster integer math computation:\r\n\r\n```python\r\nsubmsec_nsec = 456700  # 0.4567 milliseconds expressed as nanosecond-precision ticks\r\nsubmsec_frac_bin_from_nsec = (submsec_nsec << 12) // 1_000_000\r\n\r\nassert submsec_frac_bin_from_nsec == 1870\r\n```\r\n\r\nThe latter logic is more friendly with the `clock_gettime` C function than the original approach. Plus, the original is less useful in that it requires the floating-point math for rounding.\r\n\r\nPlease also find a quick Rust code that demonstrates a couple of techniques to arrive at the binary fractional representation of a submillisecond timestamp:\r\n\r\n```rust\r\nconst SUBMSEC_SIZE: u64 = 12;\r\nconst SUBMSEC_MASK: u64 = (1 << SUBMSEC_SIZE) - 1;\r\n\r\n// iterate subsecond timestamp ticks of nanosecond resolution over one second, emulating all\r\n// the possible `tv_nsec` values returned by `clock_gettime(3)`\r\nfor tv_nsec in 0u64..1_000_000_000 {\r\n    let _msec = tv_nsec / 1_000_000;\r\n    let submsec = tv_nsec % 1_000_000;\r\n\r\n    // get fractional submsec representation using floating-point math\r\n    let submsec_fraction = submsec as f64 / 1_000_000f64;\r\n    let result_fp = (submsec_fraction * (1 << SUBMSEC_SIZE) as f64).trunc() as u64;\r\n\r\n    // get fractional submsec representation using integer math\r\n    let result_int = (submsec << SUBMSEC_SIZE) / 1_000_000;\r\n    assert_eq!(result_fp, result_int);\r\n\r\n    // get fractional submsec representation directly from `tv_nsec`\r\n    let result_from_nsec = ((tv_nsec << SUBMSEC_SIZE) / 1_000_000) & SUBMSEC_MASK;\r\n    assert_eq!(result_fp, result_from_nsec);\r\n}\r\n```\r\n\r\n**Update**: After further investigation, I now believe the original text is somewhat flawed and must be fixed:\r\n\r\n- The phrase \"round to an integer\" is ambiguous because there are multiple ways to round a floating-point number to an integer (e.g., half to even, half to odd, banker's rounding, and more). The v7 spec must be specific here because two different implementations must produce exactly the same integer from the same submillisecond timestamp to guarantee sortability.\r\n- A ties-to-nearest rounding mode makes the probabilities of producing zero and 4095 (the maximum) be half of other integers in between.",
          "createdAt": "2023-05-16T03:56:13Z",
          "updatedAt": "2023-05-16T13:11:12Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The introduction of Method 4 seems to require some updates to [5.7. UUID Version 7](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html#name-uuid-version-7):\r\n\r\n---\r\n\r\n> UUID version 7 also has improved entropy characteristics over versions 1 or 6.\r\n\r\nThis statement in the first paragraph no longer holds unless the size of Method 4 timestamp is limited to 11 bits or less.\r\n\r\n---\r\n\r\n> rand_a:\r\n> 12 bits pseudo-random data to provide uniqueness as per Section 6.8 and/or an optional counter to guarantee additional monotonicity as per Section 6.2.\r\n>\r\n> var:\r\n> (snip)\r\n>\r\n> rand_b:\r\n> The final 62 bits of pseudo-random data to provide uniqueness as per Section 6.8 and/or an optional counter to guarantee additional monotonicity as per Section 6.2.\r\n\r\nThe explanation of rand_a and rand_b has to be updated to accept the Method 4 timestamp. Perhaps, we should add some clarifying text like:\r\n\r\n> The rand_a and rand_b fields, jointly, MUST be filled with a combination of the following subfields, in this order from the most significant bits to the least:\r\n>\r\n> 1.  An OPTIONAL submillisecond timestamp fraction (12 bits at maximum) to utilize extra clock resolution as per Section 6.2 (Method 4).\r\n> 2.  An OPTIONAL counter to guarantee additional monotonicity as per Section 6.2 (Method 1 or 2).\r\n> 3.  Random data to provide uniqueness as per Section 6.8.\r\n",
          "createdAt": "2023-05-19T00:28:50Z",
          "updatedAt": "2023-05-19T00:55:24Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK \r\nRegarding this proposed text:\r\n\r\n> Using floating point math, multiply this fraction of a millisecond value by 4096 and round down (toward zero) to an integer result to arrive at a number between 0 and the maximum allowed for the indicated bits which is sorts monotonically based on time.\r\n\r\nI totally agree, rounding down is better here - more explicit and easier to understand.  I'm 100% good with that change.\r\n\r\nOn the other text changes, my concerns are:\r\n* Language like \"The rand_a and rand_b fields, jointly, MUST be filled with a combination of the following subfields\" I think is too strict.  E.g. if some vendor wants to put some server node ID in here somewhere, we shouldn't explicitly prohibit that if it doesn't interfere with the basic parsing properties (in other words the random part is just random, if the generator wants to do something a bit different lose some entropy in the process - that's up to them - see the Global and Local Uniquess section).\r\n* I don't entirely agree that CSPRNG data is fundamentally going to result in less random data.  Let's say we have 12 bits that are generated with a CSPRNG and 12 bits which are a fraction of a millisecond - is there some mathematical property which says that it is less likely that the CSPRNG values will collide than two IDs will be generated in the exact same instant?  I realize some clocks may have less granularity available, but that's exactly why we want to make the length implementation dependent.  In general, I would be okay with suggesting 12 bits as a recommended length, but I think putting an absolute limit on there is too restrictive. If people want to put more precise clock data in there to express a more specific timestamp, and let's say due to clock granularity problems this reduces entropy, I think this is a tradeoff an implementation should be allowed to make.\r\n\r\nIn terms of workflow on some of these, for specific text changes it might be easier to just do a pull request and you can also link to it here - but that way the exact changes can be discussed and if there is consensus just merged in.\r\n",
          "createdAt": "2023-05-19T04:50:17Z",
          "updatedAt": "2023-05-19T04:50:17Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I totally agree, rounding down is better here\r\n\r\nWill craft a PR for this!\r\n\r\n> Language like \"The rand_a and rand_b fields, jointly, MUST be filled with a combination of the following subfields\" I think is too strict.\r\n\r\nWould propose an alternative wording: \"The rand_a and rand_b fields, jointly, <del>MUST be</del><ins>are</ins> filled with a combination of the following subfields\". It doesn't change a lot, but yeah the overall 5. UUID Layouts section doesn't really employ the MUST verbiage, so v7 should definitely follow that tone.\r\n\r\nHowever, it is questionable whether compliant implementations may embed a node ID in UUIDv7; my understanding is no, they can't. It is not 100% clear because the UUID Layouts section doesn't use the BCP 14 verbiage, but it reads like none of the UUID versions other than v8 accepts a node ID inside the 128-bit space. In the literal sense, 5.4. UUID Version 4 section doesn't preclude to include a timestamp and node ID in it, but I don't think a generator that constructs a UUIDv4 from a 60-bit timestamp and 60-bit node ID is an RFC-compliant generator. Similarly, I don't believe a UUIDv7 MAY contain a node ID. Technically, [6.4. Distributed UUID Generation](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html#section-6.4) referred to by [6.7. Global and Local Uniqueness](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html#section-6.7) reads \"Implementations that choose to leverage an embedded node id SHOULD utilize UUIDv8.\", but SHOULD here is in effect MUST, I think.\r\n\r\n> I think this is a tradeoff an implementation should be allowed to make.\r\n\r\nI totally agree that the randomness vs. granular timestamp is a trade-off issue. Perhaps, there is no theoretical advantage of one option over the other, but still I believe putting an absolute limit to the timestamp would increase the overall utility of UUIDv7 for general users.\r\n\r\nOnce finalized, v7 will become popular, many implementations will emerge, and many users will use it. As a common ground, it would be helpful if the standard is clear that the uniqueness of UUIDv7 is solely dependent on CSPRNGs and reserves sufficient space for CSPRNG inputs. Then, users just need to pick a compliant library and make sure their CSPRNG is working properly. Otherwise, users have to examine the library before use to understand the source of uniqueness and satisfy all the prerequisites for that specific implementation. This could sound like an extreme, but a standard exists to coordinate implementers and users, so clarifying the responsibility boundary should be helpful. Those who want to utilize a granular timestamp should resort to UUIDv8.\r\n\r\nThis is my personal opinion, and consensus is definitely needed.\r\n\r\nI admit my opinion is somewhat biased by the [recent government scandal in my country](https://www.asahi.com/ajw/articles/14904344), where timestamp collisions caused private information leakage. Microsecond timestamps reportedly collide multiple times in the incident. It is seemingly very difficult to ensure the timestamp granularity across a system. For example:\r\n\r\n- client or server hardware or operating systems might not support granular timestamp\r\n- mice and keyboards operate on a certain timing clock and might transmit users' input at a certain cycle\r\n- routers and network switches store packets in their buffer and might send multiple requests to the server at once\r\n\r\nLearning these cases recently, I feel kind of fearful to rely deeply on timestamps to guarantee uniqueness and randomness.",
          "createdAt": "2023-05-19T14:13:51Z",
          "updatedAt": "2023-05-19T14:13:51Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Once finalized, v7 will become popular, many implementations will emerge, and many users will use it. As a common ground, it would be helpful if the standard is clear that the uniqueness of UUIDv7 is solely dependent on CSPRNGs and reserves sufficient space for CSPRNG inputs. Then, users just need to pick a compliant library and make sure their CSPRNG is working properly. Otherwise, users have to examine the library before use to understand the source of uniqueness and satisfy all the prerequisites for that specific implementation. This could sound like an extreme, but a standard exists to coordinate implementers and users, so clarifying the responsibility boundary should be helpful. Those who want to utilize a granular timestamp should resort to UUIDv8.\r\n> \r\n\r\nI completely agree with you here.\r\n",
          "createdAt": "2023-05-19T16:43:07Z",
          "updatedAt": "2023-05-19T16:43:07Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Approved the PRs for this one so it should be good to close.\r\nEdit: I am changing method 4 to method 3 as per your note on that #91 PR.\r\nWill get it here as I address the last few issues :)",
          "createdAt": "2023-05-23T14:56:17Z",
          "updatedAt": "2023-05-23T15:00:16Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDOH6Ln3M5mGUPI",
      "title": "Remove Re-randomize Until Monotonic (Method 3) section",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/87",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reference: [6.2. Monotonicity and Counters](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html#name-monotonicity-and-counters)\r\n\r\nI believe we don't need to (or simply, should not) give prominence to the Re-randomize Until Monotonic approach as Method 3, because it does not have a distinctive benefit over the other methods. To me, Method 3 doesn't seem to make sense.\r\n\r\nFirstly, the Method 3 approach is perfectly legal without this section along with Method 1 as per Fixed-Length Dedicated Counter Seeding:\r\n\r\n> When utilizing a randomly seeded counter alongside Method 1, the random value MAY be regenerated with each counter increment without impacting sortability.\r\n\r\nThe Fixed-Length Dedicated Counter Length section suggests limiting the counter length to 42 bits but does not forbid utilizing the entire random field as a counter. Method 3 is allowed under Method 1 should an implementer wish to employ it.\r\n\r\nSimplicity is not the strength of Method 3 at all. This method requires a generator to memorize the immediately preceding value and accordingly suffers from all the challenges relating to that, such as persistent storage and synchronization mechanisms. Plus, if a generator is able to memorize the previous value, just incrementing the counter field is obviously much simpler.\r\n\r\nMethod 3 could sound simple because it naturally embodies the counter overflow handling, but that is not the case. If naively implemented, a Method 3 generator enters a busy loop when it has fully consumed the counter space until the next timestamp tick. It is actually not a big deal at all either with Method 1 & 2 if it's okay to just busy-loop upon counter overflows. Challenges of overflow handling are mostly around the graceful handling of timestamp rollbacks and malfunctioning system clocks. For example, it would be a nightmare if your generator claimed 100% CPU power for busy loops when you adjusted your server's system clock back to the correct position, and thus library writers make a lot of effort with many other techniques than a busy loop to avoid such an incident. A naive Method 3 generator will never be a practical implementation.\r\n\r\nThe performance drawback is tremendous. On average, a Method 3 generator can generate only 74 UUIDs (given the 74-bit counter space) per millisecond, which is incredibly slow, even though the generator consumes a significant amount of CPU time just to throw away unnecessary random numbers.\r\n\r\nIn conclusion, I would propose to remove the Method 3 section because:\r\n\r\n- this approach is permitted without this section\r\n- this method is no simpler than the other methods\r\n- the performance drawback is significant\r\n- this method does not have a distinctive benefit or a specific use case\r\n",
      "createdAt": "2023-05-17T01:02:05Z",
      "updatedAt": "2023-05-23T14:54:56Z",
      "closedAt": "2023-05-23T14:54:56Z",
      "comments": [
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK I see where you are coming from on this. Am giving it more thought.  My goal here was to have a simple solution for monotonicity that does not require dedicated counter bits, since these reduce entropy for all values (instead of just the values that occur during the same timestamp), and requires whatever additional bookkeeping. But I also agree with the issues you've brought up.  I'll give this some thought and see if there's another approach to this which addresses those concerns.  I do think there is value in having a solution which only requires dealing with timestamp collisions as needed rather than dedicating counter bits to this in every generated value.",
          "createdAt": "2023-05-17T05:15:05Z",
          "updatedAt": "2023-05-17T05:22:27Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @bradleypeabody, I see your points. Will try to offer an alternative idea. For your entropy concern, perhaps a Method 2 counter incremented by a large random number works well. For example, if you increment the 74-bit monotonic random bits by a 64-bit random number for each generation within the same millisecond, the resulting UUIDs will be spread over the 74-bit space in a reasonably distributed and unguessable manner. This approach consumes much less CPU power than Method 3 and accommodates 1024 UUIDs per millisecond on average. This approach doesn't require bookkeeping either; the generator only needs to know the previous UUID and does not require any other state.\r\n\r\nTechnically, counters do not need a state other than the immediately preceding UUID. Please take a look at the signature of [my prototype implementation in C](https://github.com/LiosK/uuidv7-h/blob/v0.1.6/uuidv7.h#L112C1-L114). This function is based on a 42-bit Method 1 counter and equipped with fully operational counter overflow and clock rollback handling logics but does not require any state other than the previous UUID passed as an argument. If a generator can memorize the previous UUID, effectively it can do whatever it wants.",
          "createdAt": "2023-05-17T12:04:12Z",
          "updatedAt": "2023-05-17T12:04:12Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or alternatively, perhaps we can tweak the first paragraph of the following part to mention something similar to the Method 3 approach:\r\n\r\n> For single-node UUID implementations that do not need to create batches of UUIDs, the embedded timestamp within UUID version 6 and 7 can provide sufficient monotonicity guarantees by simply ensuring that timestamp increments before creating a new UUID. Distributed nodes are discussed in Section 6.4.\r\n>\r\n> Implementations SHOULD choose one method for single-node UUID implementations that require batch UUID creation, or are otherwise concerned about monotonicity with high frequency UUID generation.\r\n\r\nMethod 3 is ultimately like generating a UUIDv7 without counters and just seeing if it's greater than the previous one or not, no matter whether timestamp has incremented since the last run or not. In this sense, it is as simple as and close to the approach described in the first paragraph (\"simply ensuring that timestamp increments before creating a new UUID\"). On the other hand, Method 3 is not appropriate for the second paragraph use cases (batch UUID creation and high frequency UUID generation) as I pointed out in the original post. So, I believe it's better to merge the Method 3 ideas into the first paragraph than to emphasize it as an independent method prepared for the second paragraph use cases.\r\n",
          "createdAt": "2023-05-17T12:51:20Z",
          "updatedAt": "2023-05-17T12:51:20Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we have requirements to generate more than 74 UUID/ms [is that a typo for\n64?] on an ongoing basis, or would it be acceptable to grab timer values into\nthe future to deal with some transient burst of demand?\n\n\n",
          "createdAt": "2023-05-17T18:02:42Z",
          "updatedAt": "2023-05-17T18:02:42Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Do we have requirements to generate more than 74 UUID/ms\r\n\r\nI don't think so, but the methods 1-4 are introduced as methods used in \"batch UUID creation\" and \"high frequency UUID generation\" as clearly stated in the leading paragraph. In this sense, Method 3 is never recommended for these purposes because it generates only 74 UUIDs per millisecond despite the 100% consumption of CPU power. With the other methods, JavaScript implementations easily reach 1k+ and Rust 15k+ per millisecond without deep optimization.\r\n\r\n> 74 UUID/ms [is that a typo for 64?]\r\n\r\nIt is not a typo. UUIDv7's `rand_a` + `rand_b` fields give 74-bit space available for counters. With Method 3, the first UUID in a millisecond picks a random number from the 74-bit space, leaving on average 73-bit space available for the second trial. And, the second UUID on average picks one from the 73-bit space, leaving 72-bit space on average for the third UUID, and ....\r\n",
          "createdAt": "2023-05-17T23:54:04Z",
          "updatedAt": "2023-05-17T23:54:04Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK After looking at this newly I totally agree on this one and I think it is fine to just remove method 3.   If implementations do not need to generate more than one value per clock tick then they don't need to use any of the methods, and if they do then I agree the efficiency issues with method 3 are too great to use this.  If I have a better idea I'll propose it but yeah, method 3 should just come out.",
          "createdAt": "2023-05-19T04:54:30Z",
          "updatedAt": "2023-05-19T04:54:30Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDOH6Ln3M5mToL_",
      "title": "Fix ambiguous text around UUIDv6 clock sequence",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/89",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[5.6. UUID Version 6](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html#name-uuid-version-6)\r\n\r\n### Current text\r\n\r\n> The clock sequence bits remain unchanged from their <del>usage and </del>position in Section 5.1.\r\n>\r\n> The clock sequence and node bits SHOULD be reset to a pseudo-random value for each new UUIDv6 generated; however, implementations MAY choose to retain the old MAC address behavior from Section 5.1. For more information on MAC address usage within UUIDs see the Section 8.\r\n\r\n### Proposed text\r\n\r\n> The clock sequence <ins>and node </ins>bits remain unchanged from their position in Section 5.1.\r\n>\r\n> The clock sequence and node bits SHOULD be reset to a pseudo-random value for each new UUIDv6 generated; however, implementations MAY choose to retain the old <ins>clock sequence and </ins>MAC address behavior from Section 5.1. For more information on MAC address usage within UUIDs see the Section 8.\r\n\r\n### Rationale\r\n\r\nThe usage of the clock sequence field is technically changed because it is filled with random bits by default, though the old behavior is still permitted.",
      "createdAt": "2023-05-19T00:02:49Z",
      "updatedAt": "2023-05-23T16:39:26Z",
      "closedAt": "2023-05-23T16:39:26Z",
      "comments": []
    },
    {
      "number": 95,
      "id": "I_kwDOH6Ln3M5msCci",
      "title": "List of remarks of current draft 04",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/95",
      "state": "OPEN",
      "author": "ben221199",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As seen in #83, I made some remarks on draft 03. In this issue I will list things that are not fully handled by the current draft (04) and some additional things I have in mind:\r\n\r\n1.\tAs mentioned in #83 (point 3), I talked about the Discord variant of Twitter snowflake. Today, I was thinking about UUIDv7. I think it is better to allow other time offsets next to 1970-01-01. Why? If Twitter decides to convert their IDs to UUID, they choose the current form of UUIDv7. However, because Discord has another offset (2015-01-01), if they want to use the current form of UUIDv7, they also have to convert all there timestamps with an additional 45 years offset. I don't think this is desirable. I propose some changes on this:\r\n\t```diff\r\n\t-UUID Version 7 features a time-ordered value field derived from the\r\n\t+UUID Version 7 features a time-ordered value field containing the number\r\n\t-widely implemented and well known Unix Epoch timestamp source, the\r\n\t+of miliseconds, leap seconds excluded, since a defined offset, in most\r\n\t-number of milliseconds since midnight 1 Jan 1970 UTC, leap seconds\r\n\t+cases the RECOMMENDED offset of midnight 1 Jan 1970 UTC. If a system\r\n\t-excluded.  UUIDv7 generally has improved entropy characteristics over\r\n\t+requires a different offset to be used, another offset MAY be used.\r\n\t-UUIDv1 or UUIDv6.\r\n\t+UUIDv7 generally has improved entropy characteristics over UUIDv1 or UUIDv6.\r\n\r\n\t-UUIDv7 values are created by allocating a Unix timestamp in\r\n\t+UUIDv7 values are created by allocating a timestamp in\r\n\tmilliseconds in the most significant 48 bits and filling the\r\n\tremaining 74 bits, jointly, excluding the required version and\r\n\tvariant bits, with a combination of the following subfields, in this\r\n\torder from the most significant bits to the least:\r\n\t```\r\n---\r\n\r\n2.\tThere is a difference between UUID and GUID. Not in the wire format, but in the representation format. If a UUID/GUID has the hexadecimal value `00 11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF`, the UUID will be written like `00112233-4455-6677-8899-AABBCCDDEEFF`, where the GUID will be written like `{33221100-5544-7766-8899-AABBCCDDEEFF}`. Except the `{` and `}`, it is also vissible that some parts are flipped. This is seen in HxD (a well-known Hex-Editor), for example: ![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/12856904/f970ff75-4ff7-45aa-8e63-402de91b8184)\r\n\tI think it is worth noting that GUIDs have this effect.\r\n\r\n---\r\n\r\n3.\tI think we still have to talk about the name of `Max UUID`. I understand the people that say \"It is the maximum value\". However, the makers of RFC 4122 went with \"Nil UUID\" when talking about the \"minimum value\". I think we should stay in the same jargon when naming things. So, we rename \"Nil UUID\" to \"Min UUID\" or something, or we change \"Max UUID\" to \"Omni UUID\". I think we should go for the Nil/Omni pair rather than the Min/Max pair. For example, Min/Max doesn't make sense when looking at UUID as a 128 bit SIGNED integer. All bits set is not the maximum and all bits not is not the minimum, see https://en.wikipedia.org/wiki/Two%27s_complement. I would rather go for the Nil/Omni pair:\r\n\r\n\t**Nil** (https://en.wiktionary.org/wiki/nil#Latin) is an alternative form of \"nihil\" and means \"nothing\" in Latin. This is true, because of all bits, NOTHING is set.\r\n\t**Omni** (https://en.wiktionary.org/wiki/omni#Latin) is an declension of \"omnis\" and means \"all\" in Latin. This is true, because ALL bits are set.",
      "createdAt": "2023-05-23T21:35:58Z",
      "updatedAt": "2023-05-23T22:40:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1. Those who needs another timestamp epoch than 1970 or 1582 must use UUIDv8. It doesn't make sense to allow different epochs within the scope of UUIDv7 because the standard has to coordinate all the implementations to produce sortable values.",
          "createdAt": "2023-05-23T22:40:53Z",
          "updatedAt": "2023-05-23T22:40:53Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOH6Ln3M4-f3Vs",
      "title": "Ci fixes",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/1",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As a recent use of the template, you have picked up a few problems that can't be fixed automatically.  They are only performance problems in CI, but this should fix that up.",
      "createdAt": "2022-09-07T10:01:57Z",
      "updatedAt": "2022-09-08T11:00:09Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "925a7abe83092fa92d226fd3e3ff5a2c6a12f33e",
      "headRepository": "martinthomson/rfc4122bis",
      "headRefName": "ci-fixes",
      "headRefOid": "88e13fd7fd5be1c44d8bb64073aa7539e1d6e76e",
      "closedAt": "2022-09-08T11:00:09Z",
      "mergedAt": "2022-09-08T11:00:08Z",
      "mergedBy": "mcr",
      "mergeCommit": {
        "oid": "8d4ade67e5f4b42190b2b394a8379139a4684674"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5Bj6yI",
          "commit": {
            "abbreviatedOid": "88e13fd"
          },
          "author": "jimfenton",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I don't know much about GitHub workflows, but I'm sure Martin knows what's needed. Any comments, Michael? Otherwise I will just merge.",
          "createdAt": "2022-09-07T23:37:36Z",
          "updatedAt": "2022-09-07T23:37:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOH6Ln3M5BmLMl",
          "commit": {
            "abbreviatedOid": "88e13fd"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-08T11:00:02Z",
          "updatedAt": "2022-09-08T11:00:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOH6Ln3M5Ahsvr",
      "title": "Draft 00 - Merge RFC 4122 into TOC draft-peabody-dispatch-new-uuid-format-04",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/14",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Merge RFC4122 with draft-peabody-dispatch-new-uuid-format-04.md\r\n- Change: Reference RFC1321 to RFC6151\r\n- Change: Reference RFC2141 to RFC8141\r\n- Change: Reference RFC2234 to RFC4234\r\n- Change: Converted UUIDv1 to match UUIDv6 section from Draft 04\r\n- Change: Trimmed down the ABNF representation\r\n- Change: ITU http website to https equivalent\r\n- Errata: Bad Reference to RFC1750 \\| 3641 #4\r\n- Errata: Change MD5 website to example.com \\| 3476 #6 (Also Fixes Errata: Fix uuid_create_md5_from_name() \\| 1352 #2)\r\n- Errata: Typo in code comment \\| 6665 #11\r\n- Errata: Fix BAD OID acronym \\| 6225 #9\r\n- Errata: Incorrect Parenthesis usage Section 4.3 \\| 184 #5\r\n- Errata: Lexicographically Sorting Paragraph Fix \\| 1428 #3\r\n- Errata: Fix 4.1.3 reference to the correct bits \\| 1957 #13\r\n- Errata: Fix reference to variant in octet 8 \\| 4975 #7\r\n- Errata: Further clarify 3rd/last bit of Variant for spec \\| 5560 #8\r\n- Draft 05: B.2. Example of a UUIDv7 Value two \"var\" in table https://github.com/uuid6/uuid6-ietf-draft/issues/120\r\n- Draft 05: MUST veribage in Reliability of 6.1 https://github.com/uuid6/uuid6-ietf-draft/issues/121\r\n- Draft 05: Further discourage centralized registry for distributed UUID Generation.\r\n- New: Further Clarity of exact octet and bit of var/ver in this spec\r\n- New: Block diagram, bit layout, test vectors for UUIDv4\r\n- New: Block diagram, bit layout, test vectors for UUIDv3\r\n- New: Block diagram, bit layout, test vectors for UUIDv5\r\n- New: Add MD5 Security Considerations reference, RFC6151\r\n- New: Add SHA1 Security Considerations reference, RFC6194",
      "createdAt": "2022-10-10T22:48:32Z",
      "updatedAt": "2023-01-20T18:41:15Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "8d4ade67e5f4b42190b2b394a8379139a4684674",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-00-merge-1",
      "headRefOid": "d60a1a57ff487232ca7c77671e255ec37c506010",
      "closedAt": "2022-10-10T22:52:00Z",
      "mergedAt": "2022-10-10T22:52:00Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "26efbd0c00e6021c27418fe2d83449dfa30ecf45"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOH6Ln3M5A9ort",
      "title": "Draft 00 - Merge 2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/15",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Author Email Addresses\r\n- More Reference Updates\r\n- Some minor formatting changes\r\n- Fixed few test vectors for v7/v8 to match other test vectors\r\n- Modified TODOs",
      "createdAt": "2022-10-17T20:43:17Z",
      "updatedAt": "2023-01-20T18:41:13Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "26efbd0c00e6021c27418fe2d83449dfa30ecf45",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-00-merge-2",
      "headRefOid": "dea2e1b8d92597788ea9d6d3968a52400211c3fc",
      "closedAt": "2022-10-17T20:44:38Z",
      "mergedAt": "2022-10-17T20:44:38Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "61e9ef93bce62ecce9484432f93d36a8e4b35c16"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 32,
      "id": "PR_kwDOH6Ln3M5C4UJl",
      "title": "Draft 01 - Merge 1",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/32",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- #18 \r\n- #19 \r\n- #20 \r\n- #22 \r\n- #24\r\n- #25 \r\n- #27 \r\n- #29 \r\n- #30\r\n- #40\r\n- #33 \r\n- #39",
      "createdAt": "2022-11-14T22:10:28Z",
      "updatedAt": "2023-01-20T18:41:09Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "61e9ef93bce62ecce9484432f93d36a8e4b35c16",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-01",
      "headRefOid": "c9fe9709db753904246c7a1c4a8943b6c0a44ce0",
      "closedAt": "2023-01-20T17:12:28Z",
      "mergedAt": "2023-01-20T17:12:28Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "79a604bce3a13efd31e16aee50a29f90f9999eb7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5LP2KR",
          "commit": {
            "abbreviatedOid": "0b88cbc"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-01-19T19:11:10Z",
          "updatedAt": "2023-01-19T19:13:30Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This is wrong, it says 4 or more, and we need to say exactly 4 octets.\r\n\"*\" is the wrong modifier.\r\n\"4 hexOctet\" would actually be correct.\r\nWe should use a tool... like \"abnfgen\"  https://www.quut.com/abnfgen/\r\n",
              "createdAt": "2023-01-19T19:11:10Z",
              "updatedAt": "2023-01-19T19:13:30Z"
            },
            {
              "originalPosition": 13,
              "body": "Also, this ABNF text is duplicated.\r\n",
              "createdAt": "2023-01-19T19:12:00Z",
              "updatedAt": "2023-01-19T19:13:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDOH6Ln3M5FQO1O",
      "title": "updated text per discussion at issue 21",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/34",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This updates the wording on the clock sequence and node fields based on #21.  @kyzer-davis let me know if this format works and can just be merged or if something else is needed.",
      "createdAt": "2022-12-12T23:44:24Z",
      "updatedAt": "2023-01-19T19:23:29Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "61e9ef93bce62ecce9484432f93d36a8e4b35c16",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "issue-21",
      "headRefOid": "142ed9cfae68b4a28c5a1bc8e98a7a44816cf065",
      "closedAt": "2023-01-19T19:23:29Z",
      "mergedAt": "2023-01-19T19:23:29Z",
      "mergedBy": "mcr",
      "mergeCommit": {
        "oid": "3735c87fe54fbebb4fb847de2dab60e98a62a3b3"
      },
      "comments": [
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "close #21 ",
          "createdAt": "2023-01-19T19:23:08Z",
          "updatedAt": "2023-01-19T19:23:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDOH6Ln3M5FQdo3",
      "title": "moved iana urn registration template as directed",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/35",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@kyzer-davis here's my attempt to address #23.  Some of the text I was able to just move over from what you had there but some fields didn't have a corresponding place in the new template so I just filled it out based on what made sense to me.",
      "createdAt": "2022-12-13T00:35:10Z",
      "updatedAt": "2023-01-20T18:03:25Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "79a604bce3a13efd31e16aee50a29f90f9999eb7",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "issue-23",
      "headRefOid": "7d91e204ef906649a1e63a87ea9548a493d973f7",
      "closedAt": "2023-01-20T18:03:25Z",
      "mergedAt": "2023-01-20T18:03:25Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "2c53adc294d5db33a3b3edca2d2550f593d2a9ec"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5KjtWE",
          "commit": {
            "abbreviatedOid": "9ed7185"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Recheck the ABNF.",
          "createdAt": "2023-01-17T04:53:58Z",
          "updatedAt": "2023-01-19T19:26:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOH6Ln3M5LP--Y",
          "commit": {
            "abbreviatedOid": "9ed7185"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T19:24:57Z",
          "updatedAt": "2023-01-19T19:24:57Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "```suggestion\r\n  provided by the following ABNF {{RFC5234}}:\r\n```",
              "createdAt": "2023-01-19T19:24:57Z",
              "updatedAt": "2023-01-19T19:24:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5LQAFT",
          "commit": {
            "abbreviatedOid": "c30a465"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-01-19T19:27:05Z",
          "updatedAt": "2023-01-19T19:27:21Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Maybe the ABNF could be referenced to this document, rather than repeated in the template.\r\n",
              "createdAt": "2023-01-19T19:27:05Z",
              "updatedAt": "2023-01-19T19:27:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDOH6Ln3M5HS-eQ",
      "title": "Fix typo of MD5-LOW to SHA-LOW",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/36",
      "state": "MERGED",
      "author": "crutchcorn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I noticed while reading through the specification that there was a typo in the UUIDv5 table indicating an MD5-LOW encoding, when it should be SHA-LOW instead.\r\n\r\nThis PR:\r\n- Fixes this issue\r\n- Updates `sha` to `sha1`\r\n- Fixes another mention of MD5 in UUIDv5",
      "createdAt": "2023-01-13T03:47:16Z",
      "updatedAt": "2023-01-20T19:56:42Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "2c53adc294d5db33a3b3edca2d2550f593d2a9ec",
      "headRepository": "crutchcorn/rfc4122bis",
      "headRefName": "patch-1",
      "headRefOid": "83f5c6eca76ea6d549c32664ce8a6661e371fab0",
      "closedAt": "2023-01-20T18:28:52Z",
      "mergedAt": "2023-01-20T18:28:52Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "39bcf9e7a9b55f655a40d5c2af151aaf8815db7b"
      },
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "Also fix\r\n\r\n```\r\nFor more information on MD5 security considerations see {{RFC6194}}.\r\n```\r\n\r\n",
          "createdAt": "2023-01-19T19:22:16Z",
          "updatedAt": "2023-01-19T19:22:16Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "Why are you editing the HTML?",
          "createdAt": "2023-01-20T16:45:10Z",
          "updatedAt": "2023-01-20T16:45:10Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Why are you editing the HTML?\r\n\r\nAddressing it, I will replicate these to the markdown file on this branch.",
          "createdAt": "2023-01-20T18:13:51Z",
          "updatedAt": "2023-01-20T18:13:51Z"
        },
        {
          "author": "crutchcorn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apologies for the confusion regarding HTML/MD edits. This is my first contribution to any RFC ever, so I'm admittedly a bit lost \ud83d\ude05\n\nI'll correct for future contributions ",
          "createdAt": "2023-01-20T19:14:24Z",
          "updatedAt": "2023-01-20T19:14:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5LQBfR",
          "commit": {
            "abbreviatedOid": "067ba42"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T19:29:44Z",
          "updatedAt": "2023-01-19T19:29:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n|                            sha1_low                           |\r\n```",
              "createdAt": "2023-01-19T19:29:45Z",
              "updatedAt": "2023-01-19T19:29:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5LQB3_",
          "commit": {
            "abbreviatedOid": "a4a698c"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T19:30:30Z",
          "updatedAt": "2023-01-19T19:30:30Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "```suggestion\r\n|var|                        sha1_low                           |\r\n```",
              "createdAt": "2023-01-19T19:30:30Z",
              "updatedAt": "2023-01-19T19:30:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOH6Ln3M5IFVxn",
      "title": "Document suggestions, hopefully non-controversial",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/37",
      "state": "MERGED",
      "author": "jimfenton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a collection of small edits that it was easier to send as a pull request rather than as a text (e.g., email) submission. Most are grammatical corrections. I'm happy to discuss any that the editors or the wg might not agree with.",
      "createdAt": "2023-01-19T01:25:26Z",
      "updatedAt": "2023-01-20T18:40:29Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "39bcf9e7a9b55f655a40d5c2af151aaf8815db7b",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "fenton-edits",
      "headRefOid": "e6a100a8d41b627ac1fcb1a8efcda40e8422b107",
      "closedAt": "2023-01-20T18:40:20Z",
      "mergedAt": "2023-01-20T18:40:19Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "de99e3f070a0247fdc872f72452d200494459a4b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOH6Ln3M5IPPUU",
      "title": "Draft 01 - Merge 2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/54",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Closes #41\r\n- Closes #42\r\n- Closes #45 \r\n- Closes #46 \r\n- Closes #48\r\n- Added .txt and .html files.\r\n- Removed TODO labels\r\n- Added Draft 01 Changelog",
      "createdAt": "2023-01-20T19:09:04Z",
      "updatedAt": "2023-01-23T23:29:09Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "de99e3f070a0247fdc872f72452d200494459a4b",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-01-merge-2",
      "headRefOid": "e248f379428def93985ab05a2393d569a45ec058",
      "closedAt": "2023-01-23T22:55:02Z",
      "mergedAt": "2023-01-23T22:55:02Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "40b48c5b048be16921872ff00cee720b6bec01ed"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 58,
      "id": "PR_kwDOH6Ln3M5IsNgO",
      "title": "Fix \"MD5\" mention in SHA1 section",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/58",
      "state": "MERGED",
      "author": "astiob",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-27T16:11:53Z",
      "updatedAt": "2023-01-31T23:05:24Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "091da05ce8f38a0f952896a0031f52bb91936178",
      "headRepository": "astiob/rfc4122bis",
      "headRefName": "patch-1",
      "headRefOid": "bd92f5878e104813a6abd8827f906001790af87b",
      "closedAt": "2023-01-31T23:05:24Z",
      "mergedAt": "2023-01-31T23:05:24Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "ce92ee5e5e12849a5c279df92a9c0c6ca59f2082"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch! \r\n\r\nTagging as #59 will leave it open until I get the okay to merge in the Feb interim.\r\n\r\nThanks!",
          "createdAt": "2023-01-27T20:34:56Z",
          "updatedAt": "2023-01-27T20:34:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOH6Ln3M5I9bYl",
      "title": "Draft 02 merge 00",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/60",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Describe Nil/Max UUID in variant table #16\r\n- Further Clarify that non-descript node IDs are the preferred method in distributed UUID Generation #49\r\n- Appendix B, consistent naming #55\r\n- Remove duplicate ABNF from IANA considerations #56\r\n- Monotonic Error Checking missing newline #57\r\n- More Security Considerations Randomness #26\r\n- SHA265 UUID Generation #50\r\n- Expand multiplexed fields within v1 and v6 bit definitions # 43\r\n- Clean up text in UUIDs that Do Not Identify the Host #61\r\n- Revise UUID Generator States section #47\r\n- Expand upon why unix epoch rollover is not a problem #44",
      "createdAt": "2023-02-01T00:14:00Z",
      "updatedAt": "2023-02-16T22:13:59Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "ce92ee5e5e12849a5c279df92a9c0c6ca59f2082",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-02-merge-00",
      "headRefOid": "76366058877e63e5d8087b436259c6714240f1d3",
      "closedAt": "2023-02-16T22:13:53Z",
      "mergedAt": "2023-02-16T22:13:53Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "9fb3a609a641cba29abe32a1e977392ad5681b54"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Added first pass at #43, hit the bit layout and definitions for v1/v6 and the test vectors.\r\nNeed to discuss what we want to do with section \"Creating UUIDv1 through UUIDv5 Value\" which is relied heavily on v1 naming scheme that I just changed...\r\n\r\nPossibly need some net-new C code examples for v1, v3, v4, v5 and remove that entirely.",
          "createdAt": "2023-02-06T16:16:08Z",
          "updatedAt": "2023-02-06T16:16:08Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated to clean up some text that didn't read correctly for #61 ",
          "createdAt": "2023-02-09T21:17:27Z",
          "updatedAt": "2023-02-09T21:17:27Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Knocked out #44 after finding the supporting comment in the old tracker.\r\n",
          "createdAt": "2023-02-09T21:53:39Z",
          "updatedAt": "2023-02-09T21:53:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 63,
      "id": "PR_kwDOH6Ln3M5MJwk5",
      "title": "Minor edits that should be uncontroversial",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/63",
      "state": "MERGED",
      "author": "jimfenton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-15T22:55:07Z",
      "updatedAt": "2023-03-16T14:06:30Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "8cb1068f241ec26350aff4ad4a27b0847e42e9c6",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "jf-edits",
      "headRefOid": "c6d443146b711104f4a046256b5b040f37c22f88",
      "closedAt": "2023-03-16T14:05:02Z",
      "mergedAt": "2023-03-16T14:05:02Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "040c625ba2b177f2dd5947cff33b1fc2abf40e04"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5QGXZ1",
          "commit": {
            "abbreviatedOid": "c6d4431"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. I appreciate the review.",
          "createdAt": "2023-03-16T14:04:52Z",
          "updatedAt": "2023-03-16T14:04:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 71,
      "id": "PR_kwDOH6Ln3M5M9MdM",
      "title": "collapse UUID registration in URN name space",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/71",
      "state": "MERGED",
      "author": "mcr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-27T10:03:35Z",
      "updatedAt": "2023-04-06T13:36:33Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "2321d5c492ba2f1bb568bcbbeff5dc0dfa25e017",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "iana-suggestions",
      "headRefOid": "0f0078bf5f492e32ce73bbf29d49eed068646b5a",
      "closedAt": "2023-04-06T13:36:21Z",
      "mergedAt": "2023-04-06T13:36:21Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "b7b43690b138760c7a3d47e2e72f4da7fdaef8eb"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Also meant to comment as per my note on the mailer:\r\nI received confirmation from Gonzalo Salgueiro that the IANA template can be dropped assuming we have nothing new to add or update so that part looks good.",
          "createdAt": "2023-03-27T19:53:51Z",
          "updatedAt": "2023-03-27T19:53:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5RDIK6",
          "commit": {
            "abbreviatedOid": "9c0514d"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-27T19:51:10Z",
          "updatedAt": "2023-03-27T19:51:16Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Replied on the mailer, we decided we DO NOT want them to have registrations for these items and there are no current registrations so there is nothing to update.",
              "createdAt": "2023-03-27T19:51:11Z",
              "updatedAt": "2023-03-27T19:51:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 76,
      "id": "PR_kwDOH6Ln3M5NyIwA",
      "title": "Draft 03",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/76",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- #67\r\n- #70\r\n- #69\r\n- #66\r\n- #65\r\n- #73\r\n- #68\r\n- #74\r\n- Misc formatting changes to address IDNITS feedback\r\n- #75",
      "createdAt": "2023-04-06T16:14:09Z",
      "updatedAt": "2023-04-11T13:53:55Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "b7b43690b138760c7a3d47e2e72f4da7fdaef8eb",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-03",
      "headRefOid": "64c64838c5fcf32f78328131ad433fc1211a5b44",
      "closedAt": "2023-04-11T13:53:55Z",
      "mergedAt": "2023-04-11T13:53:55Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "d123ba9fa37c401721b71b12ce95d99e30016ae9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 77,
      "id": "PR_kwDOH6Ln3M5N2OBi",
      "title": "Formatting suggestions",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/77",
      "state": "CLOSED",
      "author": "mcr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This deals with the code nit, and turns the examples into tables.\r\n",
      "createdAt": "2023-04-07T16:34:48Z",
      "updatedAt": "2023-04-11T13:53:27Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "b7b43690b138760c7a3d47e2e72f4da7fdaef8eb",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "formatting-suggestions",
      "headRefOid": "a4b4db9172f3b6794d669a0779d6e6cd82124d1a",
      "closedAt": "2023-04-11T13:53:26Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed on mailer, the HTML tables are pretty ugly and break up the formatting flow for these appendix sections.\r\n\r\nMain driver to get these to tables was to fix the idnits errors; however, I was able to fix that in #76 so these can stay as ascii and thematically all the examples are the same format. Which is a bit easier on the eyes IMO.\r\n\r\nAs such, I have committed the `~~~~ code` changes under https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/76/commits/64c64838c5fcf32f78328131ad433fc1211a5b44 so I will close this PR and merge that to main.",
          "createdAt": "2023-04-11T13:53:26Z",
          "updatedAt": "2023-04-11T13:53:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5SJTwU",
          "commit": {
            "abbreviatedOid": "a4b4db9"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Couple of small typos. Haven't rendered it to see how the tables look but assume someone has.",
          "createdAt": "2023-04-10T21:44:17Z",
          "updatedAt": "2023-04-10T21:47:48Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "```suggestion\r\nrandom_a   | 48  |    0x919108f752d1 |\r\n```",
              "createdAt": "2023-04-10T21:44:17Z",
              "updatedAt": "2023-04-10T21:47:48Z"
            },
            {
              "originalPosition": 251,
              "body": "```suggestion\r\ncustom_a  |  48   | 0x320C3D4DCC00  |\r\n```",
              "createdAt": "2023-04-10T21:45:39Z",
              "updatedAt": "2023-04-10T21:47:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDOH6Ln3M5N4UV4",
      "title": "typographical fixes",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/78",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some typo fixes, hopefully zero controversy.",
      "createdAt": "2023-04-09T00:13:08Z",
      "updatedAt": "2023-04-11T13:58:55Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "d123ba9fa37c401721b71b12ce95d99e30016ae9",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "20230407-typographical",
      "headRefOid": "74f669629ab0fb1672e8f87a17c6cab3aac46346",
      "closedAt": "2023-04-11T13:58:54Z",
      "mergedAt": "2023-04-11T13:58:54Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "4b49bbe28476d66fea49bb4544eaba7c38dda090"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging #76 to main caused some merge conflicts. Will fix and merge this as well.",
          "createdAt": "2023-04-11T13:56:10Z",
          "updatedAt": "2023-04-11T13:56:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5SJVFQ",
          "commit": {
            "abbreviatedOid": "87d8a0b"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good. As editors, you can assume consensus on editorial things like this; don't let approvals hold you up.",
          "createdAt": "2023-04-10T21:50:49Z",
          "updatedAt": "2023-04-10T21:50:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJVW-",
          "commit": {
            "abbreviatedOid": "87d8a0b"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Oops, meant to approve",
          "createdAt": "2023-04-10T21:52:17Z",
          "updatedAt": "2023-04-10T21:52:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDOH6Ln3M5N4WTP",
      "title": "clarifications",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/79",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Here are some clarifications I'd like to make on various pieces of text.  These shouldn't have a significant semantic change in terms of what we are specifying, but hopefully provide more clarity on specific topics that I though should have a bit more detail.  I'll also add some review notes to give more on the motivation for each change in cases where it may not be obvious.",
      "createdAt": "2023-04-09T01:07:31Z",
      "updatedAt": "2023-04-11T14:09:38Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "4b49bbe28476d66fea49bb4544eaba7c38dda090",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "20230408-clarifications",
      "headRefOid": "8ec22e8e6a1457036662af7bd0268e3c980b7e13",
      "closedAt": "2023-04-11T14:09:38Z",
      "mergedAt": "2023-04-11T14:09:38Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "ab9e03fe1e0e1a7f10d973712f50b9af9f78fcca"
      },
      "comments": [
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@jimfenton I agree with all of your edits, those have been updated.",
          "createdAt": "2023-04-10T23:55:47Z",
          "updatedAt": "2023-04-10T23:55:47Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed merge conflicts, good to go, merging down.",
          "createdAt": "2023-04-11T14:09:31Z",
          "updatedAt": "2023-04-11T14:09:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5SEKB4",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:09:00Z",
          "updatedAt": "2023-04-09T01:09:01Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I think it's important to not over-promise here - we can't actually guarantee uniqueness, but we can deliver a high probability. I think the wording should reflect that.",
              "createdAt": "2023-04-09T01:09:01Z",
              "updatedAt": "2023-04-09T03:49:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKDW",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:10:37Z",
          "updatedAt": "2023-04-09T01:10:38Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This language is from the old RFC, and I'm not sure it makes sense to leave in here.  If we're going to say that there is another document that takes precedence over this one then we should link to it and make it part of the formal spec, otherwise I think we should just take this reference to DCE standards out.",
              "createdAt": "2023-04-09T01:10:37Z",
              "updatedAt": "2023-04-09T01:10:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKFH",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:12:55Z",
          "updatedAt": "2023-04-09T01:12:56Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "With the bit space available it is possible to generate much more than 10 million identifiers per second so I think we should indicate that so people don't think it's somehow hard-limited to this.",
              "createdAt": "2023-04-09T01:12:55Z",
              "updatedAt": "2023-04-09T01:12:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKFm",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:13:29Z",
          "updatedAt": "2023-04-09T01:13:29Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Since the recommendation is that applications use an internal binary representation, I think it makes mores sense to indicate that if an application has to use text, it should use this format.",
              "createdAt": "2023-04-09T01:13:29Z",
              "updatedAt": "2023-04-09T16:47:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKF5",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:13:52Z",
          "updatedAt": "2023-04-09T01:13:53Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Just to clarify that it's decimal",
              "createdAt": "2023-04-09T01:13:53Z",
              "updatedAt": "2023-04-09T01:13:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKGV",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:14:18Z",
          "updatedAt": "2023-04-09T01:14:18Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "We might as well include the exact number of bits here - 122 - since we mention it.",
              "createdAt": "2023-04-09T01:14:18Z",
              "updatedAt": "2023-04-09T01:14:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKGq",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:14:40Z",
          "updatedAt": "2023-04-09T01:14:40Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I think it's helpful to provide some context as to why this is here.",
              "createdAt": "2023-04-09T01:14:40Z",
              "updatedAt": "2023-04-09T01:14:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKG9",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:15:00Z",
          "updatedAt": "2023-04-09T01:15:00Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Same thing, just so there's no question about the rationale for this.",
              "createdAt": "2023-04-09T01:15:00Z",
              "updatedAt": "2023-04-09T01:15:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKHQ",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:15:14Z",
          "updatedAt": "2023-04-09T01:15:14Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "It doesn't necessarily format as a \"bullet\"",
              "createdAt": "2023-04-09T01:15:14Z",
              "updatedAt": "2023-04-09T01:15:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKIh",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:16:19Z",
          "updatedAt": "2023-04-09T01:16:19Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "I think this communicates the point - an implementation, wherever possible, should prevent a duplicate value from being returned as part of being a correct implementation.  Or to state it another way: if you could have easily prevented returning a value but did not, that's a bug that should be fixed.",
              "createdAt": "2023-04-09T01:16:19Z",
              "updatedAt": "2023-04-09T16:49:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKJa",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:17:35Z",
          "updatedAt": "2023-04-09T01:17:36Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "I think providing the inline definition of \"monotonicity\" here is helpful, since strictly speaking from the mathematical definition this could also describe values that count down, or that count in a constant direction based on specific input.  We might as well spell out exactly what we mean here.",
              "createdAt": "2023-04-09T01:17:35Z",
              "updatedAt": "2023-04-09T01:17:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKJs",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:18:17Z",
          "updatedAt": "2023-04-09T01:18:17Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "Batch creation is an important use case but really this section applies to any code that is concerned about creating a whole bunch of UUIDs on a single node, so I think the additional wording helps with that.",
              "createdAt": "2023-04-09T01:18:17Z",
              "updatedAt": "2023-04-09T01:18:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKKo",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:19:32Z",
          "updatedAt": "2023-04-09T01:19:32Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "I think it's helpful to indicate that if the implementation gets into some sort of pickle where it cannot return a unique ID, that returning an error instead is perhaps the right behavior.",
              "createdAt": "2023-04-09T01:19:32Z",
              "updatedAt": "2023-04-09T01:19:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKLG",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:20:06Z",
          "updatedAt": "2023-04-09T01:20:06Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I know we say MAY in the next paragraph but when I read this again it seemed to communicate that this was an expected part of the implementation, so I think adding this helps.",
              "createdAt": "2023-04-09T01:20:06Z",
              "updatedAt": "2023-04-09T01:20:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKL2",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:21:13Z",
          "updatedAt": "2023-04-09T01:21:13Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Do we really want to suggest to people that they use the namespace variant?  If a system has let's say a known insecure random number generator, then sure that is going to affect the quality of the output, but I'm not sure that's a strong enough concern to suggest the namespace variant.",
              "createdAt": "2023-04-09T01:21:13Z",
              "updatedAt": "2023-04-09T01:21:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKME",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:21:53Z",
          "updatedAt": "2023-04-09T01:21:53Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "Same logic as earlier - we can't guarantee uniqueness in all cases, we're basically saying it's good enough for practical purposes.",
              "createdAt": "2023-04-09T01:21:53Z",
              "updatedAt": "2023-04-09T01:21:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKNl",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:23:21Z",
          "updatedAt": "2023-04-09T01:23:22Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "I think this helps give more guidance on the opacity concern.  My rationale here is that people writing UUID libraries and such will have to make a decision about how much parsing capability to include, and I don't want people to feel compelled to provide a bunch of detailed parsing, when one of the whole drives of these new UUIDs is that they are more useful as opaque values.  So with this wording I think it's more clear and will ease the implementation burden.",
              "createdAt": "2023-04-09T01:23:21Z",
              "updatedAt": "2023-04-09T01:23:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJWAt",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T21:55:42Z",
          "updatedAt": "2023-04-10T21:55:42Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I've been wondering why they call this a \"nil UUID\" rather than a \"null UUID\" (which makes more sense to me), but I think that ship has already sailed.",
              "createdAt": "2023-04-10T21:55:42Z",
              "updatedAt": "2023-04-10T21:55:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJW_j",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Minor suggestions, otherwise ready to go.",
          "createdAt": "2023-04-10T21:59:51Z",
          "updatedAt": "2023-04-10T22:02:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Serial comma:\r\n```suggestion\r\nto implement services using UUIDs, as URNs {{RFC8141}}, or otherwise.\r\n```",
              "createdAt": "2023-04-10T21:59:52Z",
              "updatedAt": "2023-04-10T22:02:04Z"
            },
            {
              "originalPosition": 32,
              "body": "\"up to...or more\" doesn't really make sense:\r\n```suggestion\r\nhigh allocation rates of 10 million per second per machine or more if\r\n```",
              "createdAt": "2023-04-10T22:00:46Z",
              "updatedAt": "2023-04-10T22:02:04Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\nA Max UUID value can be used as a sentinel value in situations where a 128-bit UUID is required but a concept such as \"end of UUID list\" needs to be expressed, and is reserved for such use as needed for implementation-specific situations.\r\n```",
              "createdAt": "2023-04-10T22:01:34Z",
              "updatedAt": "2023-04-10T22:02:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SNykj",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-11T14:05:44Z",
          "updatedAt": "2023-04-11T14:05:45Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "This was text from 4122: https://www.rfc-editor.org/rfc/rfc4122#section-6\r\n\r\nIf we want to have a larger discussion about this text I am fine with opening an issue and shooting something to the mailer. ",
              "createdAt": "2023-04-11T14:05:44Z",
              "updatedAt": "2023-04-11T14:05:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDOH6Ln3M5N4XAS",
      "title": "some SHOULD/MUST adjustments",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/80",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "These are a few SHOULD/MUST adjustments that I think help improve the accuracy.  I won't die over these but would be good to merge if others agree.",
      "createdAt": "2023-04-09T01:31:23Z",
      "updatedAt": "2023-04-11T14:11:23Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "b7b43690b138760c7a3d47e2e72f4da7fdaef8eb",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "20230408-should-must-ify",
      "headRefOid": "b0170a733c86c6b1a8f56b89d13739fa5fbc7e27",
      "closedAt": "2023-04-11T14:11:23Z",
      "mergedAt": "2023-04-11T14:11:23Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "1a742f443fde44309790fa95b7d93e3c752db5a7"
      },
      "comments": [
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@jimfenton Thanks for the feedback, I've fixed the issues you brought up.",
          "createdAt": "2023-04-10T23:45:04Z",
          "updatedAt": "2023-04-10T23:45:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5SEKUD",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:32:25Z",
          "updatedAt": "2023-04-09T01:32:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Since all of the time UUIDs only use either Gregorian or Unix timestamp, and v8 is the only option where you can do something else, it should be fine to convert this to a MUST.",
              "createdAt": "2023-04-09T01:32:25Z",
              "updatedAt": "2023-04-09T01:32:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKV6",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:34:59Z",
          "updatedAt": "2023-04-09T01:35:00Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "My concern on this one is that stalling the clock or erroring are not necessarily the only viable solutions to this problem.  But I'm on the fence on this one.  I think I also added separately in another PR a \"MUST NOT\" sentence that says the thing that it really cannot do is return a knowingly duplicated value, which I think is the key point to stress here.",
              "createdAt": "2023-04-09T01:34:59Z",
              "updatedAt": "2023-04-09T01:35:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKWe",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:35:57Z",
          "updatedAt": "2023-04-09T01:35:58Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This entire thing is a suggestion, so I'm not sure it makes sense to use MUST here, it's sort of like saying \"this is just advice and only way to solve the problem, but if you're listing, you MUST do it this way...\" - I think a SHOULD makes more sense.",
              "createdAt": "2023-04-09T01:35:57Z",
              "updatedAt": "2023-04-09T01:35:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKXS",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:37:04Z",
          "updatedAt": "2023-04-09T01:37:04Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "While I like the notion that careless implementations are incorrect \ud83d\ude04, I'm not sure that saying people MUST take here works here.  Probably better to just take it out.",
              "createdAt": "2023-04-09T01:37:04Z",
              "updatedAt": "2023-04-09T01:37:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJYA3",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "A couple of suggestions here. Please avoid language like \"Care SHOULD/MUST be taken\" (e.g., line 1208) because it's not possible to verify whether care was taken or not, only whether the thing was done. Use the more straightforward imperative; it's also something that can be verified.",
          "createdAt": "2023-04-10T22:05:17Z",
          "updatedAt": "2023-04-10T22:14:14Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\n: Select a counter bit-length that can properly handle\r\n```",
              "createdAt": "2023-04-10T22:05:17Z",
              "updatedAt": "2023-04-10T22:14:14Z"
            },
            {
              "originalPosition": 23,
              "body": "The text is saying here that there are two ways to solve the problem. If the second choice is used and the counter isn't incremented, the problem isn't necessarily solved. I prefer the MUST.",
              "createdAt": "2023-04-10T22:10:36Z",
              "updatedAt": "2023-04-10T22:14:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJbHj",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T22:20:49Z",
          "updatedAt": "2023-04-10T22:20:49Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Okay cool, I'm all good with striking this change then and leaving it how it was (MUST).",
              "createdAt": "2023-04-10T22:20:49Z",
              "updatedAt": "2023-04-10T22:20:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJncC",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "greatestape",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T23:35:26Z",
          "updatedAt": "2023-04-10T23:35:26Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Should this be in passive voice like the text above it? Like \"Implementations using a fixed-length counter method SHOULD use a counter bit-length that can properly handle the level of timestamp precision in use.\"\r\n\r\n(Sorry, I'm just lurking and cheering you all on! I'm excited for uuidv7!)",
              "createdAt": "2023-04-10T23:35:26Z",
              "updatedAt": "2023-04-10T23:48:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJoYn",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T23:42:45Z",
          "updatedAt": "2023-04-10T23:42:46Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "@greatestape thanks for the suggestion, I think Jim's suggested edit handles it though, I'll proceed with that.",
              "createdAt": "2023-04-10T23:42:45Z",
              "updatedAt": "2023-04-10T23:42:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOH6Ln3M5N5FJW",
      "title": "add two more methods to the monotonic section",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/81",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After reading through everything again, while the monotonic/counter section works as it stands now, I think it would greatly benefit from two other specific suggested methods for achieving monotonicity.\r\n\r\nThe first I think is beneficial because it is trivial to implement (just keep generating random values until you get one that is greater than the last), and implementors prioritizing simplicity would benefit from it.\r\n\r\nAnd the second brings back a concept that I originally proposed in the initial draft for UUID v7 (using bits in the UUID that immediately follow the timestamp to encode more timestamp precision in a way that is time ordered), but later removed because it was often misunderstood.  However, I think the key benefit to this approach (just using the additional precision available in the system clock for what it is meant for) still exists and makes sense, and having it here as an optional feature so implementations are not required to understand and use it if they don't need to - I believe that tradeoff makes a lot of sense.  I tried to keep it super simple by just giving an example of how to use it, and people can infer the underlying math/theory or not as needed.",
      "createdAt": "2023-04-09T17:55:16Z",
      "updatedAt": "2023-04-11T14:17:45Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "b7b43690b138760c7a3d47e2e72f4da7fdaef8eb",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "20230408-timestamp-stuff",
      "headRefOid": "2711ac4300090ca52218c23ffc70987bfc3406c9",
      "closedAt": "2023-04-11T14:17:45Z",
      "mergedAt": "2023-04-11T14:17:45Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "9927b324d497741f9ff16446da46e8b4ce3184c7"
      },
      "comments": [
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@jimfenton Thanks for the feedback, I did the edits you suggested and split up Method 4 into a few paragraphs and added a normative description as you suggest.  Let me know if there's anything else you think I should adjust immediately and otherwise I agree it would be good to get more feedback from others and go from there.",
          "createdAt": "2023-04-11T01:14:30Z",
          "updatedAt": "2023-04-11T01:14:30Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Verified Method 3 and 4 render properly with author-tools in HTML/TXT formats. Merging down.",
          "createdAt": "2023-04-11T14:17:40Z",
          "updatedAt": "2023-04-11T14:17:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5SEnj0",
          "commit": {
            "abbreviatedOid": "e347984"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T18:16:42Z",
          "updatedAt": "2023-04-09T18:16:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This is the same edit from here https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/79#discussion_r1161177270",
              "createdAt": "2023-04-09T18:16:42Z",
              "updatedAt": "2023-04-09T18:16:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJa4R",
          "commit": {
            "abbreviatedOid": "e347984"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Mostly editorial fixes suggested; I think we need more input on this. They both need to be expressed in normative language\r\n\r\nMethod 4 mixes the normative requirements with an example. Suggest pulling the example into one or more separate paragraphs so the reader can distinguish between what they are required to do and the example of how to do it.",
          "createdAt": "2023-04-10T22:19:32Z",
          "updatedAt": "2023-04-10T22:25:01Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n  of implementation. One downside to this approach is the fact that\r\n```",
              "createdAt": "2023-04-10T22:19:32Z",
              "updatedAt": "2023-04-10T22:25:01Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n  generation will become increasingly slow for a given timestamp value as\r\n```",
              "createdAt": "2023-04-10T22:20:02Z",
              "updatedAt": "2023-04-10T22:25:01Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n  more attempts are required to produce monotonic output, and the fact that\r\n```",
              "createdAt": "2023-04-10T22:20:32Z",
              "updatedAt": "2023-04-10T22:25:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDOH6Ln3M5OYskQ",
      "title": "Removed extra \"seconds\" word",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/82",
      "state": "MERGED",
      "author": "oittaa",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-04-15T13:05:53Z",
      "updatedAt": "2023-05-10T18:06:45Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "e54464db613a65b7f30d53035ecb3ccb48dbd492",
      "headRepository": "oittaa/rfc4122bis",
      "headRefName": "patch-1",
      "headRefOid": "ddc3f1d0c0a66706e98997be41a1ce1063c791b6",
      "closedAt": "2023-05-10T18:06:44Z",
      "mergedAt": "2023-05-10T18:06:44Z",
      "mergedBy": "mcr",
      "mergeCommit": {
        "oid": "ab9e948e6f73c494fc099d0aad38ff09bacda867"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 84,
      "id": "PR_kwDOH6Ln3M5QgtwF",
      "title": "Punctuation and minor style fixes",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/84",
      "state": "MERGED",
      "author": "petere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Mostly add and remove some commas, some titlecase fixes, and random odd bits.",
      "createdAt": "2023-05-15T12:56:30Z",
      "updatedAt": "2023-05-15T13:31:57Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "ab9e948e6f73c494fc099d0aad38ff09bacda867",
      "headRepository": "petere/rfc4122bis",
      "headRefName": "style-fixes",
      "headRefOid": "ac65eb8bc43871656fcaf86983f0b754651a8a87",
      "closedAt": "2023-05-15T13:31:57Z",
      "mergedAt": "2023-05-15T13:31:56Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @petere! ",
          "createdAt": "2023-05-15T13:31:45Z",
          "updatedAt": "2023-05-15T13:31:45Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 88,
      "id": "PR_kwDOH6Ln3M5Qzn8I",
      "title": "Remove extra words",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/88",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-18T13:20:46Z",
      "updatedAt": "2023-05-23T14:38:45Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d",
      "headRepository": null,
      "headRefName": "main",
      "headRefOid": "6624c2c7b1e177ad1df92f26e93a99e3fe7a42cc",
      "closedAt": "2023-05-23T14:38:45Z",
      "mergedAt": "2023-05-23T14:38:45Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "0f776572716418d4cb3a2bc886cb5914f01077f1"
      },
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/ddc3f1d0c0a66706e98997be41a1ce1063c791b6 edited a different file, didn't it?",
          "createdAt": "2023-05-18T13:22:24Z",
          "updatedAt": "2023-05-18T13:22:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 90,
      "id": "PR_kwDOH6Ln3M5Q7jLv",
      "title": "Change rounding mode of Method 4 Section 6.2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/90",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes the rounding mode demonstrated in Replace Left-Most Random Bits with Increased Clock Precision (Method 4) from ties-to-nearest to round-down-toward-zero.\r\n\r\nhttps://github.com/ietf-wg-uuidrev/rfc4122bis/issues/86#issuecomment-1548940686",
      "createdAt": "2023-05-20T00:41:38Z",
      "updatedAt": "2023-05-23T14:47:31Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d",
      "headRepository": null,
      "headRefName": "rounding",
      "headRefOid": "1f411ba21fd84c31498f0ce30a13d303a97cb99d",
      "closedAt": "2023-05-23T14:47:31Z",
      "mergedAt": "2023-05-23T14:47:30Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "c08c9da7a7567c49a7a3f5e493f5a48e9588d6fc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 91,
      "id": "PR_kwDOH6Ln3M5Q7qE0",
      "title": "Add verbal description of v7 generation to 5.7. UUID Version 7",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/91",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Whether to limit the size of Method 4 clock precision is still under discussion in https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/86, but aside from that point, I believe we should update the 5.7. UUID Version 7 section to make it consistent with Method 4.\r\n\r\nThe UUIDv7 structure is currently hard to understand because in my opinion it lacks a verbal description of the generation algorithm other than the field definitions below the layout figure, while other versions include some textual descriptions in their respective sections.\r\n\r\nAs a starting point, I have summarized my understanding as follows and created this PR.\r\n\r\n> UUIDv7 values are created by allocating a Unix timestamp in milliseconds in the most significant 48 bits and filling the remaining 74 bits, jointly, excluding the required version and variant bits, with a combination of the following subfields, in this order from the most significant bits to the least:\r\n>\r\n> 1. An OPTIONAL submillisecond timestamp fraction to utilize extra clock precision as per Section 6.2 (Method 4).\r\n> 2. An OPTIONAL carefully seeded counter to guarantee additional monotonicity as per Section 6.2 (Method 1 or 2).\r\n> 3. Random data for each new UUIDv7 generated to provide uniqueness as per Section 6.8 for any remaining space.\r\n\r\nAs @bradleypeabody pointed out in https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/86#issuecomment-1553990440, there are some disagreements around here, so discussion and consensus are definitely needed.\r\n",
      "createdAt": "2023-05-20T02:50:27Z",
      "updatedAt": "2023-05-23T14:52:05Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d",
      "headRepository": null,
      "headRefName": "describe_v7",
      "headRefOid": "c0d445d569493d3ec99fa650948bc935de7b9e9b",
      "closedAt": "2023-05-23T14:52:05Z",
      "mergedAt": "2023-05-23T14:52:05Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "12dbda1bb565ac1c514112b02051f3a567b4b21c"
      },
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note: Once the size of Method 4 extra timestamp is limited to 12 bits as per https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/86:\r\n\r\n- Insert the threshold like: \"1. An OPTIONAL submillisecond timestamp fraction <ins>(12 bits at maximum) </ins>to utilize extra clock precision as per Section 6.2 (Method 4).\"\r\n- Revert the `rand_b` field description because it won't accommodate extra clock precision: \"The final 62 bits of pseudo-random data to provide uniqueness as per Section 6.8 and/or an optional counter to guarantee additional monotonicity as per Section 6.2.\"\r\n\r\nNote: Method 4 must be renamed to Method 3 once https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/92 is accepted.",
          "createdAt": "2023-05-21T01:48:03Z",
          "updatedAt": "2023-05-21T01:48:03Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 92,
      "id": "PR_kwDOH6Ln3M5Q8sAc",
      "title": "Remove Re-randomize Until Monotonic (Method 3) from Monotonicity and Counters",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/92",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/87",
      "createdAt": "2023-05-21T01:21:31Z",
      "updatedAt": "2023-05-23T14:54:55Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d",
      "headRepository": null,
      "headRefName": "rem_method_3",
      "headRefOid": "34d47354712c12ee8a018cb34eded00338119937",
      "closedAt": "2023-05-23T14:54:54Z",
      "mergedAt": "2023-05-23T14:54:54Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "b224cb8e76ce3bd0259eaa16f5c90ed820e36462"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 93,
      "id": "PR_kwDOH6Ln3M5Q96yr",
      "title": "Remove extra \"a\"",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/93",
      "state": "MERGED",
      "author": "DianaNites",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-22T01:51:26Z",
      "updatedAt": "2023-05-23T14:55:20Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d",
      "headRepository": "DianaNites/rfc4122bis",
      "headRefName": "patch-1",
      "headRefOid": "83b5eadcba76fd75396bd09ddf07b4f4c09170e2",
      "closedAt": "2023-05-23T14:55:19Z",
      "mergedAt": "2023-05-23T14:55:19Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "e2b5021f4fad65cd1de30bc4ae0425f687695230"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5VkuUU",
          "commit": {
            "abbreviatedOid": "83b5ead"
          },
          "author": "cbandy",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-22T02:44:00Z",
          "updatedAt": "2023-05-22T02:44:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDOH6Ln3M5RKnc6",
      "title": "WGLC Midterm Merge",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/94",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Fix ambiguous text around UUIDv6 clock sequence #89\r\n- Move endianness statement from layout to format section #85\r\n- Further modified abstract to separate URN topic from UUID definition #83\r\n- Provided three more UUID format examples #83\r\n- Added text further clarifying version construct is for the variant in this doc #83\r\n- Provided further clarification for local/global bit vs multicast bit #83",
      "createdAt": "2023-05-23T16:37:26Z",
      "updatedAt": "2023-05-23T16:39:28Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "e2b5021f4fad65cd1de30bc4ae0425f687695230",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "wglc-midterm",
      "headRefOid": "b930708ead92fa13a6372f69bc1669532549224c",
      "closedAt": "2023-05-23T16:39:23Z",
      "mergedAt": "2023-05-23T16:39:23Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "91de9d156d5e40f76089ae2898fce9ddfd1b63fa"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 96,
      "id": "PR_kwDOH6Ln3M5RPA1o",
      "title": "Align Method 3 text with the 12 bits limitation",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/96",
      "state": "OPEN",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Would propose small changes to Method 3 (the old Method 4) to align with the 12 bits limitation.\r\n\r\n#86",
      "createdAt": "2023-05-24T11:09:37Z",
      "updatedAt": "2023-05-24T11:09:37Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "aaa7ac9a90c9a541ed06747ed1ec075ce036e1bd",
      "headRepository": "LiosK/rfc4122bis",
      "headRefName": "cleanup_method3",
      "headRefOid": "e40267ba59d0f86ef599ac67ce5aa4a9b73a54d0",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 97,
      "id": "PR_kwDOH6Ln3M5RPEZ7",
      "title": "Make Version/version casing consistent across 5. UUID Layouts",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/97",
      "state": "OPEN",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix inconsistent casing of \"UUID Version X\" and \"UUID version X\" in Section 5. UUID Layouts. Though I am not sure if \"version\" is better than \"Version\" or not, at least the lowercase \"version\" improves consistency across the document.",
      "createdAt": "2023-05-24T11:19:36Z",
      "updatedAt": "2023-05-24T11:19:36Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "aaa7ac9a90c9a541ed06747ed1ec075ce036e1bd",
      "headRepository": "LiosK/rfc4122bis",
      "headRefName": "consistent_casing",
      "headRefOid": "ffa95bcf498cf70be901ec2720bf977de95c55b0",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}